Перем Настройки Экспорт;

Перем ЕстьИзменения;
Перем кэшРазделителиСлов;
Перем мНовыйКод;
Перем мНовыйКодИзменен;
Перем мТекПустыхСтрок;
Перем мМаксПустыхСтрок;

// Выравнивает код по установленным фрагментам
//
// Параметры:
//  ИсходныйКод  - ТабличныйДокумент - Код для выравнивания.
//
// Возвращаемое значение:
//   Булево   - Есть изменения
//
Функция ВыровнитьКод(ИсходныйКод) Экспорт
	
	ЕстьИзменения = Ложь;
	
	ФорматироватьПереносы(ИсходныйКод);
	
	// Выравнивание по фрагментам
	
	Для каждого цФрагмент Из ФрагментыВыравнивания() Цикл
		
		ВыровнитьКодПоФрагменту(ИсходныйКод, цФрагмент);
		
	КонецЦикла;
	
	Возврат ЕстьИзменения;
	
КонецФункции

Процедура ФорматироватьПереносы(пИсходныйКод)
	
	мНовыйКодИзменен = Ложь;
	
	мНовыйКод  = Новый ТекстовыйДокумент;
	мМаксПустыхСтрок                = МаксПустыхСтрок();
	мТекПустыхСтрок                 = 0;
	предСтрока = "";
	отложеннаяУстановкаПустойСтроки = Ложь;
	этоСерияПеренесенныхВыражений   = Ложь;
	удалитьТабов                    = 0;
	
	Для цНомерСтроки = 1 По пИсходныйКод.КоличествоСтрок() Цикл
		
		цТекСтрока     = пИсходныйКод.ПолучитьСтроку(цНомерСтроки);
		строкаИзменена = Ложь;
		
		строкаИзменена = СдвинутьКодПоИнструкциямПрепроцессора(цТекСтрока, удалитьТабов) ИЛИ строкаИзменена;
		
		Если ДобавитьПустуюСтрокуПосле(цТекСтрока, предСтрока, отложеннаяУстановкаПустойСтроки) Тогда
			
			отступы = ПолучитьОтступы(цТекСтрока);
			ДобавитьВРезультат(отступы);
			мНовыйКодИзменен = Истина;
			предСтрока       = отступы;
			
		КонецЕсли;
		
		Если ДобавитьПустуюСтрокуДо(цТекСтрока, предСтрока) Тогда
			
			ДобавитьВРезультат(ПолучитьОтступы(предСтрока));
			мНовыйКодИзменен = Истина;
			
		КонецЕсли;
		
		строкаИзменена = УдалитьЛишниеПробельныеСимволы(цТекСтрока) ИЛИ строкаИзменена;
		строкаИзменена = ПривестиЗапятыеКНорме(цТекСтрока) ИЛИ строкаИзменена;
		
		Для каждого цЗнак Из АрифметическиеЗнаки() Цикл
			
			строкаИзменена = ПривестиАрифметическиеЗнакиКНорме(цТекСтрока, цЗнак, предСтрока) ИЛИ строкаИзменена;
			
		КонецЦикла;
		
		строкаИзменена = ПривестиЗнакиРавноКНорме(цТекСтрока) ИЛИ строкаИзменена;
		строкаИзменена = ПривестиСкобкиКНорме(цТекСтрока) ИЛИ строкаИзменена;
		строкаИзменена = УдалитьПробелыСправа(цТекСтрока) ИЛИ строкаИзменена;
		
		строкаИзменена = УстановитьОтступПеренесеннымСтрокам(цТекСтрока,
															 предСтрока,
															 этоСерияПеренесенныхВыражений) ИЛИ строкаИзменена;
		
		РазбитьДлинныеВыражения(цТекСтрока, строкаИзменена, 0, этоСерияПеренесенныхВыражений);
		РазбитьВыраженияПоПереносам(цТекСтрока, строкаИзменена);
		
		Если строкаИзменена Тогда
			
			мНовыйКодИзменен = Истина;
			
		КонецЕсли;
		
		ДобавитьВРезультат(цТекСтрока);
		предСтрока = цТекСтрока;
		
	КонецЦикла;
	
	Если мНовыйКодИзменен Тогда
		
		ЕстьИзменения = Истина;
		пИсходныйКод  = мНовыйКод;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьВРезультат(Знач пСтрока)
	
	Если ПустаяСтрока(пСтрока) Тогда
		
		мТекПустыхСтрок = мТекПустыхСтрок + 1;
		
	Иначе
		
		мТекПустыхСтрок = 0;
		
	КонецЕсли;
	
	Если Не ПустаяСтрока(пСтрока)
		ИЛИ мТекПустыхСтрок <= мМаксПустыхСтрок Тогда
		
		мНовыйКод.ДобавитьСтроку(ПробелыВТабы(пСтрока));
		
	Иначе
		
		мНовыйКодИзменен = Истина;
		
	КонецЕсли;
	
КонецПроцедуры

#Область Настройки

Функция ПолучитьНастройку(Знач пИмя, Знач пЗначениеПоУмолчанию)
	
	значениеНастройки = Настройки[пИмя];
	
	Если значениеНастройки = Неопределено Тогда
		
		значениеНастройки = пЗначениеПоУмолчанию;
		
	КонецЕсли;
	
	Возврат значениеНастройки;
	
КонецФункции

Функция СдвигПревышение()
	
	Возврат ПолучитьНастройку("СдвигПревышение", 12);
	
КонецФункции

// Если перенесенное выражение будет иметь сдвиг больше, то сдвиг будет рассчитан иначе.
Функция ОграничениеСдвига()
	
	Возврат 20;
	
КонецФункции

Функция ДобавлятьПробелыВнутриСкобок()
	
	Возврат ПолучитьНастройку("ДобавлятьПробелыВнутриСкобок", Истина);
	
КонецФункции

Функция ДобавлятьПробелыВнутриКвадратныхСкобок()
	
	Возврат ПолучитьНастройку("ДобавлятьПробелыВнутриКвадратныхСкобок", Ложь);
	
КонецФункции

Функция ОграничениеДлиныСтроки()
	
	Возврат ПолучитьНастройку("ОграничениеДлиныСтроки", 120);
	
КонецФункции

Функция ДобавлятьПустыеСтрокиПередКомментарием()
	
	Возврат ПолучитьНастройку("ДобавлятьПустыеСтрокиПередКомментарием", Истина);
	
КонецФункции

Функция ДобавлятьПустыеСтрокиВокругКлючевыхКонструкций()
	
	Возврат ПолучитьНастройку("ДобавлятьПустыеСтрокиВокругКлючевыхКонструкций", Истина);
	
КонецФункции

Функция МаксПустыхСтрок()
	
	Возврат ПолучитьНастройку("МаксПустыхСтрок", 3);
	
КонецФункции

Функция ИспользоватьПробелыДляВыравнивания()
	
	Возврат ПолучитьНастройку("ИспользоватьПробелыДляВыравнивания", Ложь);
	
КонецФункции

Функция УдалятьПробелМеждуЗапятыми()
	
	Возврат ПолучитьНастройку("УдалятьПробелМеждуЗапятыми", Ложь);
	
КонецФункции

// 0 - не выравнивать
// 1 - добавлять таб
// 2 - выравнивать по равно/скобке.
Функция РежимВыравниванияТекстов()
	
	Возврат ПолучитьНастройку("РежимВыравниванияТекстов", 0);
	
КонецФункции

Функция ВыравниватьПоРавно()
	
	Возврат ПолучитьНастройку("ВыравниватьПоРавно", Истина);
	
КонецФункции

Функция ВыравниватьПоСкобке()
	
	Возврат ПолучитьНастройку("ВыравниватьПоСкобке", Истина);
	
КонецФункции

Функция ВыравниватьПоЗапятой()
	
	Возврат ПолучитьНастройку("ВыравниватьПоЗапятой", Истина);
	
КонецФункции

Функция ВыравниватьПоКомментариям()
	
	Возврат ПолучитьНастройку("ВыравниватьПоКомментариям", Истина);
	
КонецФункции

#КонецОбласти

#Область КлючевыеФрагменты

Функция ФрагментыВыравнивания()
	
	фрагментыВыравнивания = Новый СписокЗначений;
	
	Если ВыравниватьПоРавно() Тогда
		
		фрагментыВыравнивания.Добавить("=", "Право");
		
	КонецЕсли;
	
	Если ВыравниватьПоСкобке() Тогда
		
		фрагментыВыравнивания.Добавить("(", "Лево");
		
	КонецЕсли;
	
	Если ВыравниватьПоЗапятой() Тогда
		
		фрагментыВыравнивания.Добавить(",", "Лево");
		
	КонецЕсли;
	
	Если ВыравниватьПоКомментариям() Тогда
		
		фрагментыВыравнивания.Добавить("//", "Право");
		
	КонецЕсли;
	
	Возврат фрагментыВыравнивания;
	
КонецФункции

Функция АрифметическиеЗнаки()
	
	Возврат СтрРазделить("<=,>=,<>,+,-,<,>", ",");
	
КонецФункции

Функция КлючевыеСловаПрепроцессораНачало()
	
	слова = Новый Соответствие;
	
	слова.Вставить("#ЕСЛИ", Истина);
	слова.Вставить("#ИНАЧЕЕСЛИ", Истина);
	слова.Вставить("#ИНАЧЕ", Истина);
	
	Возврат слова;
	
КонецФункции

Функция КлючевыеСловаПрепроцессораКонец()
	
	слова = Новый Соответствие;
	
	слова.Вставить("#ИНАЧЕЕСЛИ", Истина);
	слова.Вставить("#ИНАЧЕ", Истина);
	слова.Вставить("#КОНЕЦЕСЛИ", Истина);
	
	Возврат слова;
	
КонецФункции

Функция КлючевыеСловаПрепроцессора()
	
	слова = КлючевыеСловаПрепроцессораНачало();
	
	Для каждого цЭлемент Из КлючевыеСловаПрепроцессораКонец() Цикл
		
		слова.Вставить(цЭлемент.Ключ, цЭлемент.Значение);
		
	КонецЦикла;
	
	Возврат слова;
	
КонецФункции

Функция КлючевыеСловаОбласть()
	
	слова = Новый Соответствие;
	
	слова.Вставить("#ОБЛАСТЬ", Истина);
	слова.Вставить("#КОНЕЦОБЛАСТИ", Истина);
	
	Возврат слова;
	
КонецФункции

Функция РазделителиБлоков()
	
	слова = Новый Соответствие;
	
	ДобавитьСлова_Если(слова);
	
	слова.Вставить("ТОГДА", Истина);
	слова.Вставить("ИЗ", Истина);
	слова.Вставить("ДЛЯ", Истина);
	слова.Вставить("КАЖДОГО", Истина);
	слова.Вставить("ПО", Истина);
	слова.Вставить("ЦИКЛ", Истина);
	слова.Вставить("ПОКА", Истина);
	слова.Вставить("ПРОЦЕДУРА", Истина);
	слова.Вставить("ФУНКЦИЯ", Истина);
	слова.Вставить("FUNCTION", Истина);
	слова.Вставить("ПЕРЕМ", Истина);
	слова.Вставить("ЗНАЧ", Истина);
	слова.Вставить("ПЕРЕЙТИ", Истина);
	слова.Вставить("ВЫЗВАТЬИСКЛЮЧЕНИЕ", Истина);
	слова.Вставить("ПОПЫТКА", Истина);
	слова.Вставить("ИСКЛЮЧЕНИЕ", Истина);
	слова.Вставить("ВОЗВРАТ", Истина);
	слова.Вставить("RETURN", Истина);
	
	ДобавитьСлова_ЛогическиеОперации(слова);
	ДобавитьСлова_Экспорт(слова);
	ДобавитьСлова_Конец(слова);
	
	Для каждого цСлово Из КлючевыеСловаПрепроцессора() Цикл
		
		слова.Вставить(цСлово.Ключ, цСлово.Значение);
		
	КонецЦикла;
	
	Возврат слова;
	
КонецФункции

// Слова, после которых должна быть пустая строка
// 0 - не добавлять
// 1 - добавить пустую строку после, если у следующей строки не 1
// 2 - добавить пустую строку после
// 3 - добавить пустую строку до
// 4 - добавить пустые строки до и после.
Функция КлючевыеСловаДляДобавленияПустыхСтрок()
	
	Слова = Новый Соответствие;
	Слова.Вставить("ФУНКЦИЯ", 2);
	Слова.Вставить("ПРОЦЕДУРА", 2);
	Слова.Вставить("КОНЕЦЕСЛИ", 4);
	Слова.Вставить("КОНЕЦЦИКЛА", 4);
	Слова.Вставить("ДЛЯ", 3);
	Слова.Вставить("ПОКА", 3);
	Слова.Вставить("ЦИКЛ", 4);
	Слова.Вставить("ЕСЛИ", 3);
	Слова.Вставить("ТОГДА", 2);
	Слова.Вставить("ИНАЧЕ", 4);
	Слова.Вставить("#ЕСЛИ", 4);
	Слова.Вставить("ИНАЧЕЕСЛИ", 3);
	Слова.Вставить("#ИНАЧЕ", 4);
	Слова.Вставить("#ИНАЧЕЕСЛИ", 3);
	Слова.Вставить("#КОНЕЦЕСЛИ", 4);
	Слова.Вставить("#КОНЕЦОБЛАСТИ", 4);
	Слова.Вставить("КОНЕЦПРОЦЕДУРЫ", 4);
	Слова.Вставить("КОНЕЦФУНКЦИИ", 4);
	Слова.Вставить("ЭКСПОРТ", 2);
	Слова.Вставить("КОНЕЦПОПЫТКИ", 2);
	Слова.Вставить("ВОЗВРАТ", 4);
	
	Возврат Слова;
	
КонецФункции

// Ключевые слова, которые должны быть последними в строке
Функция КлючевыеСловаЗавершения()
	
	слова = Новый Соответствие;
	
	слова.Вставить(";", Ложь);
	слова.Вставить("ТОГДА", Истина);
	слова.Вставить("THEN", Истина);
	слова.Вставить("ИНАЧЕ", Истина);
	слова.Вставить("ЦИКЛ", Истина);
	
	ДобавитьСлова_Экспорт(слова);
	ДобавитьСлова_Конец(слова);
	
	Возврат слова;
	
КонецФункции

// Ключевые слова, которые должны быть в начале строки
Функция КлючевыеСловаНачала()
	
	слова = Новый Соответствие;
	
	слова.Вставить("ФУНКЦИЯ", Истина);
	слова.Вставить("ПРОЦЕДУРА", Истина);
	слова.Вставить("ДЛЯ", Истина);
	слова.Вставить("ПОКА", Истина);
	слова.Вставить("ПОПЫТКА", Истина);
	слова.Вставить("ИСКЛЮЧЕНИЕ", Истина);
	слова.Вставить("ВОЗВРАТ", Истина);
	
	ДобавитьСлова_Если(слова);
	ДобавитьСлова_Конец(слова);
	
	Возврат слова;
	
КонецФункции

Функция КлючевыеСловаДляУвеличенияОтступов()
	
	слова = Новый Соответствие;
	
	слова.Вставить("ФУНКЦИЯ", Истина);
	слова.Вставить("ПРОЦЕДУРА", Истина);
	слова.Вставить("ДЛЯ", Истина);
	слова.Вставить("ПОКА", Истина);
	слова.Вставить("ИНАЧЕ", Истина);
	слова.Вставить("ПОПЫТКА", Истина);
	слова.Вставить("ИСКЛЮЧЕНИЕ", Истина);
	
	ДобавитьСлова_Если(слова);
	
	Возврат слова;
	
КонецФункции

Функция КлючевыеСловаДляУменьшенияОтступов()
	
	слова = Новый Соответствие;
	
	ДобавитьСлова_Конец(слова);
	
	Возврат слова;
	
КонецФункции

Функция КлючевыеСловаСОбязательнымПробеломПередСкобкой()
	
	слова = Новый Соответствие;
	
	ДобавитьСлова_Если(слова);
	ДобавитьСлова_ЛогическиеОперации(слова);
	слова.Вставить("#ЕСЛИ", Истина);
	слова.Вставить("#IF", Истина);
	слова.Вставить("#ИНАЧЕЕСЛИ", Истина);
	слова.Вставить("#ELSIF", Истина);
	слова.Вставить("ПОКА", Истина);
	слова.Вставить("WHILE", Истина);
	слова.Вставить("ВОЗВРАТ", Истина);
	слова.Вставить("RETURN", Истина);
	
	Возврат слова;
	
КонецФункции

Процедура ДобавитьСлова_Конец(слова)
	
	слова.Вставить("КОНЕЦЦИКЛА", Истина);
	слова.Вставить("ENDDO", Истина);
	слова.Вставить("КОНЕЦЕСЛИ", Истина);
	слова.Вставить("ENDIF", Истина);
	слова.Вставить("КОНЕЦПРОЦЕДУРЫ", Истина);
	слова.Вставить("ENDPROCEDURE", Истина);
	слова.Вставить("КОНЕЦФУНКЦИИ", Истина);
	слова.Вставить("ENDFUNCTION", Истина);
	слова.Вставить("КОНЕЦПОПЫТКИ", Истина);
	слова.Вставить("ENDTRY", Истина);
	
КонецПроцедуры

Процедура ДобавитьСлова_Если(слова)
	
	слова.Вставить("ЕСЛИ", Истина);
	слова.Вставить("IF", Истина);
	слова.Вставить("ИНАЧЕЕСЛИ", Истина);
	слова.Вставить("ELSIF", Истина);
	
КонецПроцедуры

Процедура ДобавитьСлова_ЛогическиеОперации(слова)
	
	слова.Вставить("И", Истина);
	слова.Вставить("ИЛИ", Истина);
	слова.Вставить("НЕ", Истина);
	
	слова.Вставить("AND", Истина);
	слова.Вставить("OR", Истина);
	слова.Вставить("NOT", Истина);
	
КонецПроцедуры

Процедура ДобавитьСлова_Экспорт(слова)
	
	слова.Вставить("ЭКСПОРТ", Истина);
	слова.Вставить("EXPORT", Истина);
	
КонецПроцедуры

Функция КлючевыеСловаДляПодтвержденияУнарныхОпераций()
	
	слова = РазделителиБлоков();
	
	слова.Вставить(";", Ложь);
	слова.Вставить(",", Ложь);
	слова.Вставить("%", Ложь);
	слова.Вставить(":", Ложь);
	слова.Вставить("(", Ложь);
	слова.Вставить("=", Ложь);
	слова.Вставить("*", Ложь);
	слова.Вставить("+", Ложь);
	слова.Вставить("-", Ложь);
	
	Возврат слова;
	
КонецФункции

#КонецОбласти

#Область Поиск

Функция ПозицияФрагмента(Знач пСтрока, Знач пФрагмент, Знач ИскатьОтдельноеСлово = Ложь)
	
	позицияФрагмента = СтрНайти(пСтрока, пФрагмент);
	
	Если ИскатьОтдельноеСлово Тогда
		
		Пока Не позицияФрагмента = 0 Цикл
			
			Если ЭтоОтдельноеСлово(пФрагмент, пСтрока, позицияФрагмента) Тогда
				
				Прервать;
				
			КонецЕсли;
			
			Если позицияФрагмента = СтрДлина(пСтрока) Тогда
				
				позицияФрагмента = 0;
				Прервать;
				
			КонецЕсли;
			
			позицияФрагмента = СтрНайти(пСтрока, пФрагмент, , позицияФрагмента + 1);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если позицияФрагмента = 0 Тогда
		
		Возврат 0;
		
	КонецЕсли;
	
	Если Не пФрагмент = "//" Тогда
		
		ПозицияКомментария = ПозицияФрагмента(пСтрока, "//");
		
		Если ПозицияКомментария > 0
			И ПозицияКомментария < позицияФрагмента Тогда
			
			Возврат 0;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ПозицияКавычек = СтрНайти(пСтрока, """");
	
	// Проверяем есть ли вначале строки символ "|".
	ПервыйСимвол = Сред(СокрЛП(пСтрока), 1, 1);
	
	Если пФрагмент = "|"
		И ПервыйСимвол = "|" Тогда
		
		Возврат позицияФрагмента;
		
	КонецЕсли;
	
	// Нет кавычек, оставляем весь комментарий.
	// Кавычки после комментария, оставляем весь комментарий.
	
	Если (ПозицияКавычек = 0 ИЛИ ПозицияКавычек > позицияФрагмента)
		И ПервыйСимвол <> "|" Тогда
		
		Возврат позицияФрагмента;
		
	ИначеЕсли ПервыйСимвол = "|"
		И ПозицияКавычек = 0 Тогда
		
		// Все в строке
		
		Возврат 0;
		
	ИначеЕсли ПервыйСимвол = "|"
		И ПозицияКавычек > 0 Тогда
		
		строкаПослеКавычек = Сред(пСтрока, ПозицияКавычек + 1);
		
		позицияФрагмента = ПозицияФрагмента(строкаПослеКавычек, пФрагмент);
		
		Если позицияФрагмента = 0 Тогда
			
			Возврат 0;
			
		Иначе
			
			Возврат ПозицияКавычек + позицияФрагмента;
			
		КонецЕсли;
		
	Иначе
		
		строкаПослеКавычек = "|" + Сред(пСтрока, ПозицияКавычек + 1);
		
		позицияФрагмента = ПозицияФрагмента(строкаПослеКавычек, пФрагмент);
		
		Если позицияФрагмента = 0 Тогда
			
			Возврат 0;
			
		Иначе
			
			Возврат ПозицияКавычек + позицияФрагмента - 1;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

Функция ПозицияОткрывающейсяСкобки(Знач пСтрока)
	
	позицияСкобки     = ПозицияФрагмента(пСтрока, "(");
	сдвигПоискаСкобки = 0;
	
	Пока Не позицияСкобки = 0 Цикл
		
		строкаПослеСкобки = Сред(пСтрока, позицияСкобки + 1);
		
		Если Не СтрНачинаетсяС(СокрЛ(строкаПослеСкобки), ")") Тогда
			
			Прервать;
			
		КонецЕсли;
		
		сдвигПоискаСкобки = сдвигПоискаСкобки + позицияСкобки + 1;
		позицияСкобки     = ПозицияФрагмента(строкаПослеСкобки, "(");
		
	КонецЦикла;
	
	Если позицияСкобки > 0 Тогда
		
		позицияСкобки = позицияСкобки + сдвигПоискаСкобки;
		
	КонецЕсли;
	
	Возврат позицияСкобки;
	
КонецФункции

Функция ПозицияЗакрывающейсяСкобки(Знач пСтрока)
	
	позицияСкобки     = ПозицияФрагмента(пСтрока, ")");
	сдвигПоискаСкобки = 0;
	
	Пока Не позицияСкобки = 0 Цикл
		
		строкаДоСкобки    = Лев(пСтрока, позицияСкобки - 1);
		строкаПослеСкобки = Сред(пСтрока, позицияСкобки + 1);
		
		Если Не СтрЗаканчиваетсяНа(СокрП(строкаДоСкобки), "(") Тогда
			
			Прервать;
			
		КонецЕсли;
		
		сдвигПоискаСкобки = сдвигПоискаСкобки + позицияСкобки + 1;
		позицияСкобки     = ПозицияФрагмента(строкаПослеСкобки, "(");
		
	КонецЦикла;
	
	Если позицияСкобки > 0 Тогда
		
		позицияСкобки = позицияСкобки + сдвигПоискаСкобки;
		
	КонецЕсли;
	
	Возврат позицияСкобки;
	
КонецФункции

Функция ПозицияРазрыва(Знач пТекСтрока, Знач пФрагмент, Знач пИскатьОтдельноеСлово = Ложь)
	
	ТЕКСТРОКА      = ВРег(пТекСтрока);
	ФРАГМЕНТ       = ВРег(пФрагмент);
	длинаФрагмента = СтрДлина(ФРАГМЕНТ);
	
	Если СтрНачинаетсяС(СокрЛ(ТЕКСТРОКА), ФРАГМЕНТ) Тогда
		
		первоеУпоминание = ПозицияФрагмента(ТЕКСТРОКА, ФРАГМЕНТ, пИскатьОтдельноеСлово);
		новСтрокаПоиска  = Сред(ТЕКСТРОКА, первоеУпоминание + длинаФрагмента);
		позицияФрагмента = ПозицияФрагмента(новСтрокаПоиска, ФРАГМЕНТ, пИскатьОтдельноеСлово);
		
		Если позицияФрагмента > 0 Тогда
			
			позицияФрагмента = позицияФрагмента + первоеУпоминание + длинаФрагмента - 1;
			
		КонецЕсли;
		
	Иначе
		
		позицияФрагмента = ПозицияФрагмента(ТЕКСТРОКА, ФРАГМЕНТ, пИскатьОтдельноеСлово);
		
	КонецЕсли;
	
	Возврат позицияФрагмента;
	
КонецФункции

Функция ЭтоЗавершеннаяСтрокаКода(Знач пСтрока)
	
	Если ПустаяСтрока(пСтрока) Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	строкаБезКомментариев = СокрЛП(КодБезКомментариев(пСтрока));
	
	Если ПустаяСтрока(строкаБезКомментариев) Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Если КодЗаканчиваетсяНа_ОдинИзФрагментов(строкаБезКомментариев, КлючевыеСловаЗавершения()) Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Если (КодНачинаетсяНа(строкаБезКомментариев, "Функция", Истина)
		ИЛИ КодНачинаетсяНа(строкаБезКомментариев, "Процедура", Истина))
		И КодЗаканчиваетсяНа(строкаБезКомментариев, ")") Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Если КодНачинаетсяНа(строкаБезКомментариев, "&На") Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Если КодНачинаетсяНа_ОдинИзФрагментов(строкаБезКомментариев, КлючевыеСловаОбласть()) Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Если КодНачинаетсяНа_ОдинИзФрагментов(строкаБезКомментариев, КлючевыеСловаПрепроцессора()) Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция СтрокаКодаУвеличенияОтступа(Знач пСтрока)
	
	Если ПустаяСтрока(пСтрока) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Для каждого цЭлемент Из КлючевыеСловаДляУвеличенияОтступов() Цикл
		
		Если КодНачинаетсяНа(пСтрока, цЭлемент.Ключ, цЭлемент.Значение) > 0 Тогда
			
			Возврат Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция СтрокаКодаУменьшенияОтступа(Знач пСтрока)
	
	Если ПустаяСтрока(пСтрока) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Для каждого цЭлемент Из КлючевыеСловаДляУменьшенияОтступов() Цикл
		
		Если КодНачинаетсяНа(пСтрока, цЭлемент.Ключ, цЭлемент.Значение) > 0 Тогда
			
			Возврат Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция КодЗаканчиваетсяНа(Знач пСтрокаКода, Знач пФрагмент, Знач ЭтоСлово = Ложь)
	
	Если ПустаяСтрока(пСтрокаКода)
		И Не ПустаяСтрока(пФрагмент) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	КОД      = ВРег(СокрП(пСтрокаКода));
	ФРАГМЕНТ = ВРег(пФрагмент);
	
	позицияФрагмента = ПозицияФрагмента(КОД, ФРАГМЕНТ, ЭтоСлово);
	
	Если позицияФрагмента = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	позицияНачалаФрагментаВКонце = (СтрДлина(КОД) - СтрДлина(ФРАГМЕНТ) + 1);
	
	Если позицияФрагмента = позицияНачалаФрагментаВКонце Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Если позицияНачалаФрагментаВКонце < позицияФрагмента Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат КодЗаканчиваетсяНа(Сред(КОД, позицияФрагмента + 1), пФрагмент, ЭтоСлово);
	
КонецФункции

Функция КодЗаканчиваетсяНа_ОдинИзФрагментов(Знач пСтрока, Знач пСлова)
	
	Для каждого цСлово Из пСлова Цикл
		
		Если КодЗаканчиваетсяНа(пСтрока, цСлово.Ключ, цСлово.Значение) Тогда
			
			Возврат Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция КодНачинаетсяНа_ОдинИзФрагментов(Знач пСтрока, Знач пСлова)
	
	Для каждого цСлово Из пСлова Цикл
		
		Если КодНачинаетсяНа(пСтрока, цСлово.Ключ, цСлово.Значение) Тогда
			
			Возврат Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция КодНачинаетсяНа(Знач пСтрокаКода, Знач пФрагмент, Знач ЭтоСлово = Ложь)
	
	КОД      = ВРег(СокрЛ(пСтрокаКода));
	ФРАГМЕНТ = ВРег(пФрагмент);
	
	Возврат ПозицияФрагмента(КОД, ФРАГМЕНТ, ЭтоСлово) = 1;
	
КонецФункции

Функция КодЧислоВхождений(Знач пСтрокаКода, Знач пФрагмент, Знач ЭтоСлово = Ложь)
	
	числоВхождений = 0;
	
	КОД      = ВРег(СокрП(пСтрокаКода));
	ФРАГМЕНТ = ВРег(пФрагмент);
	
	позицияФрагмента = ПозицияФрагмента(КОД, ФРАГМЕНТ, ЭтоСлово);
	
	Пока позицияФрагмента > 0 Цикл
		
		числоВхождений = числоВхождений + 1;
		
		КОД              = Сред(КОД, позицияФрагмента + 1, ЭтоСлово);
		позицияФрагмента = ПозицияФрагмента(КОД, ФРАГМЕНТ, ЭтоСлово);
		
	КонецЦикла;
	
	Возврат числоВхождений;
	
КонецФункции

Функция КодЗаменитьВсе(Знач пСтрока, Знач пПодстрокаПоиска, Знач пПодстрокаЗамены)
	
	позиция           = ПозицияФрагмента(пСтрока, пПодстрокаПоиска);
	длинаСтрокиПоиска = СтрДлина(пПодстрокаПоиска);
	
	Пока позиция > 0 Цикл
		
		пСтрока = Лев(пСтрока, позиция - 1) + пПодстрокаЗамены + Сред(пСтрока, позиция + длинаСтрокиПоиска);
		
		позиция = ПозицияФрагмента(пСтрока, пПодстрокаПоиска);
		
	КонецЦикла;
	
	Возврат пСтрока;
	
КонецФункции

Функция КодБезКомментариев(Знач пСтрока)
	
	ПозицияКомментария = ПозицияФрагмента(пСтрока, "//");
	
	Если ПозицияКомментария = 0 Тогда
		
		Возврат пСтрока;
		
	Иначе
		
		Возврат Лев(пСтрока, ПозицияКомментария - 1);
		
	КонецЕсли;
	
КонецФункции

// Разбивает строку на несколько строк, используя заданный набор разделителей.
// Если параметр РазделителиСлов не задан, то разделителем слов считается любой из символов,
// не относящихся к символам латиницы, кириллицы, цифры, подчеркивания.
//
// Параметры:
//  Значение        - Строка - исходная строка, которую необходимо разложить на слова.
//  РазделителиСлов - Строка - перечень символов-разделителей. Например, ".,;".
//
// Возвращаемое значение:
//  Массив - список слов.
//
// Пример:
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов("один-@#два2_!три") возвратит массив значений: "один",
//  "два2_", "три"; СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов("один-@#два2_!три", "#@!_") возвратит массив
//  значений: "один-", "два2", "три".
//
Функция РазложитьСтрокуВМассивСлов(Знач Значение) Экспорт
	
	Слова = Новый Массив;
	
	РазмерТекста = СтрДлина(Значение);
	НачалоСлова  = 1;
	
	Для Позиция = 1 По РазмерТекста Цикл
		
		КодСимвола = КодСимвола(Значение, Позиция);
		
		Если ЭтоРазделительСлов(КодСимвола) Тогда
			
			Если Позиция <> НачалоСлова Тогда
				
				Слова.Добавить(Сред(Значение, НачалоСлова, Позиция - НачалоСлова));
				
			КонецЕсли;
			
			НачалоСлова = Позиция + 1;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Позиция <> НачалоСлова Тогда
		
		Слова.Добавить(Сред(Значение, НачалоСлова, Позиция - НачалоСлова));
		
	КонецЕсли;
	
	Возврат Слова;
	
КонецФункции

// Определяет, является ли символ разделителем.
//
// Параметры:
//  КодСимвола      - Число  - код проверяемого символа;
//  РазделителиСлов - Строка - символы разделителей. Если параметр не указан, то
//                             разделителем считаются все символы, не являющиеся цифрами,
//                             латинскими и кириллическими буквами, а также знаком подчеркивания.
//
// Возвращаемое значение:
//  Булево - Истина, если символ с кодом КодСимвола является разделителем.
//
Функция ЭтоРазделительСлов(КодСимвола) Экспорт
	
	значениеКеша = кэшРазделителиСлов[КодСимвола];
	
	Если Не значениеКеша = Неопределено Тогда
		
		Возврат значениеКеша;
		
	КонецЕсли;
	
	Диапазоны = Новый Массив;
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 48, 57));     // цифры
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 65, 90));     // латиница большие
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 97, 122));    // латиница маленькие
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 1040, 1103)); // кириллица
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 1025, 1025)); // символ "Ё"
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 1105, 1105)); // символ "ё"
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 95, 95));     // символ "_"
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 35, 35));     // символ "#"
	
	Для Каждого Диапазон Из Диапазоны Цикл
		
		Если КодСимвола >= Диапазон.Мин И КодСимвола <= Диапазон.Макс Тогда
			
			кэшРазделителиСлов.Вставить(КодСимвола, Ложь);
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	кэшРазделителиСлов.Вставить(КодСимвола, Истина);
	
	Возврат Истина;
	
КонецФункции

Функция ЭтоОтдельноеСлово(Знач пСлово, Знач пСтрока, Знач пПозиция)
	
	слеваРазделитель  = Ложь;
	справаРазделитель = Ложь;
	
	Если пПозиция = 1 Тогда
		
		слеваРазделитель = Истина;
		
	Иначе
		
		слеваРазделитель = ЭтоРазделительСлов(КодСимвола(пСтрока, пПозиция - 1));
		
	КонецЕсли;
	
	позицияПравогоРазделителя = пПозиция + СтрДлина(пСлово);
	
	Если позицияПравогоРазделителя > СтрДлина(пСтрока) Тогда
		
		справаРазделитель = Истина;
		
	Иначе
		
		справаРазделитель = ЭтоРазделительСлов(КодСимвола(пСтрока, позицияПравогоРазделителя));
		
	КонецЕсли;
	
	Возврат слеваРазделитель И справаРазделитель;
	
КонецФункции

#КонецОбласти

#Область ТабоПробелы

Функция ПолучитьОтступы(Знач пСтрока)
	
	количествоОтступов = СтрДлина(пСтрока);
	
	Для ц = 1 По СтрДлина(пСтрока) Цикл
		
		Если Не ПустаяСтрока(Сред(пСтрока, ц, 1)) Тогда
			
			количествоОтступов = ц - 1;
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Лев(пСтрока, количествоОтступов);
	
КонецФункции

Функция ПробелыВТабы(Знач пСтрока)
	
	Если ИспользоватьПробелыДляВыравнивания() Тогда
		
		Возврат пСтрока;
		
	Иначе
		
		стрРезультат = КодЗаменитьВсе(пСтрока, "    ", "	");
		
		Возврат стрРезультат;
		
	КонецЕсли;
	
КонецФункции

Функция ТабыВПробелы(Знач пСтрока)
	
	Возврат КодЗаменитьВсе(пСтрока, "	", "    ");
	
КонецФункции

Функция СтрокаПробелов(Знач пКоличествоПробелов)
	
	СтрокаПробелов = "";
	
	Для СчПробелов = 1 По пКоличествоПробелов Цикл
		
		СтрокаПробелов = СтрокаПробелов + " ";
		
	КонецЦикла;
	
	Возврат СтрокаПробелов;
	
КонецФункции

#КонецОбласти

Процедура ВыровнитьКодПоФрагменту(ТекстовыйДокумент, Знач пФрагмент)
	
	фрагмент     = пФрагмент.Значение;
	выравнивание = пФрагмент.Представление;
	
	массивСтрок = Новый Массив;
	
	Для цНомерСтроки = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		
		цТекСтрока = ТекстовыйДокумент.ПолучитьСтроку(цНомерСтроки);
		
		Если фрагмент = "(" Тогда
			
			позицияФрагмента = ПозицияОткрывающейсяСкобки(цТекСтрока);
			
		Иначе
			
			позицияФрагмента = ПозицияФрагмента(цТекСтрока, фрагмент);
			
		КонецЕсли;
		
		Если позицияФрагмента > 0
			И ПодходитДляВыравнивания(цТекСтрока, позицияФрагмента) Тогда
			
			массивСтрок.Добавить(цНомерСтроки);
			
			ТекстовыйДокумент.ЗаменитьСтроку(цНомерСтроки, цТекСтрока);
			
		Иначе
			
			Если массивСтрок.Количество() > 1 Тогда
				
				РазвернутьПробелы(ТекстовыйДокумент, массивСтрок, фрагмент, выравнивание);
				
			Иначе
				
				массивСтрок = Новый Массив;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если массивСтрок.Количество() > 1 Тогда
		
		РазвернутьПробелы(ТекстовыйДокумент, массивСтрок, фрагмент, выравнивание);
		
	КонецЕсли;
	
КонецПроцедуры

Функция ПодходитДляВыравнивания(Знач пСтрока, пИндексФрагмента)
	
	Если Найти(СокрЛ(пСтрока), "//") = 1 Тогда
		
		// Если строка полностью состоит из комментария, то не трогаем ее
		
		Возврат Ложь;
		
	КонецЕсли;
	
	индексКомментария = ПозицияФрагмента(пСтрока, "//");
	
	Если пИндексФрагмента > индексКомментария
		И Не индексКомментария = 0 Тогда
		
		// Нужный фрагмент закомментирован. Так же стоит учитывать, что выравнивание может происходить как раз комментариев,
		// поэтому сравнение строгое.
		
		Возврат Ложь;
		
	КонецЕсли;
	
	массивСлов = РазложитьСтрокуВМассивСлов(СокрЛП(пСтрока));
	
	Если массивСлов.Количество() = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если Не РазделителиБлоков()[ВРег(массивСлов[0])] = Неопределено Тогда
		
		// Первое слово не является словом, разбивающем блок
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция УдалитьЛишниеПробельныеСимволы(пСтрока)
	
	Если Не ЗначениеЗаполнено(пСтрока) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	отступы           = ПолучитьОтступы(пСтрока);
	строкаБезОтступов = СокрЛ(пСтрока);
	
	позицияТаба = ПозицияФрагмента(строкаБезОтступов, "	");
	
	Пока позицияТаба > 0 Цикл
		
		строкаДо    = Лев(строкаБезОтступов, позицияТаба - 1);
		строкаПосле = Сред(строкаБезОтступов, позицияТаба + 1);
		
		строкаБезОтступов = СокрП(строкаДо) + " " + СокрЛ(строкаПосле);
		
		позицияТаба = ПозицияФрагмента(строкаБезОтступов, "	");
		
	КонецЦикла;
	
	позицияПробелов = ПозицияФрагмента(строкаБезОтступов, "  ");
	
	Пока позицияПробелов > 0 Цикл
		
		строкаДо    = Лев(строкаБезОтступов, позицияПробелов - 1);
		строкаПосле = Сред(строкаБезОтступов, позицияПробелов + 1);
		
		строкаБезОтступов = СокрП(строкаДо) + " " + СокрЛ(строкаПосле);
		
		позицияПробелов = ПозицияФрагмента(строкаБезОтступов, "  ");
		
	КонецЦикла;
	
	строкаБезОтступов = КодЗаменитьВсе(строкаБезОтступов, " ;", ";");
	строкаБезОтступов = КодЗаменитьВсе(строкаБезОтступов, ";;", ";");
	
	Если Не пСтрока = (отступы + строкаБезОтступов) Тогда
		
		пСтрока = отступы + строкаБезОтступов;
		
		Возврат Истина;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции

Функция ПривестиЗапятыеКНорме(пСтрока)
	
	Если Не ЗначениеЗаполнено(пСтрока) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат  = "";
	остатокСтроки = пСтрока;
	
	позицияЗапятой = ПозицияФрагмента(остатокСтроки, ",");
	
	Если позицияЗапятой = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Пока Не позицияЗапятой = 0 Цикл
		
		строкаПослеЗапятой = Сред(остатокСтроки, позицияЗапятой + 1);
		строкаДоЗапятой    = Лев(остатокСтроки, позицияЗапятой - 1);
		
		стрРезультат = стрРезультат + СокрП(строкаДоЗапятой) + ", ";
		
		остатокСтроки  = СокрЛ(строкаПослеЗапятой);
		позицияЗапятой = ПозицияФрагмента(остатокСтроки, ",");
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + СокрЛ(остатокСтроки);
	
	Если УдалятьПробелМеждуЗапятыми() Тогда
		
		стрРезультат = КодЗаменитьВсе(стрРезультат, ", ,", ",,");
		
	КонецЕсли;
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция ПривестиЗнакиРавноКНорме(пСтрока)
	
	Если Не ЗначениеЗаполнено(пСтрока) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат  = "";
	остатокСтроки = пСтрока;
	
	позицияРавно = ПозицияФрагмента(остатокСтроки, "=");
	
	Если позицияРавно = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Пока Не позицияРавно = 0 Цикл
		
		строкаПослеРавно = Сред(остатокСтроки, позицияРавно + 1);
		строкаДоРавно    = Лев(остатокСтроки, позицияРавно - 1);
		
		Если СтрЗаканчиваетсяНа(строкаДоРавно, ">")
			ИЛИ СтрЗаканчиваетсяНа(строкаДоРавно, "<") Тогда
			
			стрРезультат = стрРезультат + СокрП(строкаДоРавно) + "= ";
			
		Иначе
			
			стрРезультат = стрРезультат + СокрП(строкаДоРавно) + " = ";
			
		КонецЕсли;
		
		остатокСтроки = СокрЛ(строкаПослеРавно);
		позицияРавно  = ПозицияФрагмента(остатокСтроки, "=");
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + СокрЛ(остатокСтроки);
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция ПривестиАрифметическиеЗнакиКНорме(пСтрока, Знач пФрагмент, Знач пПредСтрока)
	
	Если Не ЗначениеЗаполнено(пСтрока) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат   = "";
	длинаФрагмента = СтрДлина(пФрагмент);
	остатокСтроки  = пСтрока;
	
	позицияФрагмента = ПозицияФрагмента(остатокСтроки, пФрагмент);
	
	Если позицияФрагмента = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Пока Не позицияФрагмента = 0 Цикл
		
		строкаПослеФрагмента = Сред(остатокСтроки, позицияФрагмента + длинаФрагмента);
		строкаДоФрагмента    = Лев(остатокСтроки, позицияФрагмента - 1);
		
		Если ДобавитьПробелОтОперацииТолькоСлева(пФрагмент, строкаДоФрагмента, строкаПослеФрагмента, позицияФрагмента, пПредСтрока) Тогда
			
			стрРезультат = стрРезультат + СокрП(строкаДоФрагмента) + " " + пФрагмент;
			
		ИначеЕсли пФрагмент = ">"
			И СтрЗаканчиваетсяНа(строкаДоФрагмента, "<") Тогда
			
			стрРезультат = стрРезультат + СокрП(строкаДоФрагмента) + пФрагмент + " ";
			
		Иначе
			
			стрРезультат = стрРезультат + СокрП(строкаДоФрагмента) + " " + пФрагмент + " ";
			
		КонецЕсли;
		
		остатокСтроки    = СокрЛ(строкаПослеФрагмента);
		позицияФрагмента = ПозицияФрагмента(остатокСтроки, пФрагмент);
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + СокрЛ(остатокСтроки);
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция ДобавитьПробелОтОперацииТолькоСлева(Знач пФрагмент,
											Знач строкаДоФрагмента,
											Знач строкаПослеФрагмента,
											Знач позицияФрагмента,
											Знач пПредСтрока)
											
	Если (пФрагмент = "<"
		ИЛИ пФрагмент = ">")
		И СтрНачинаетсяС(строкаПослеФрагмента, "=") Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Если пФрагмент = "<"
		И СтрНачинаетсяС(строкаПослеФрагмента, ">") Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Если ЭтоУнарнаяОперация(строкаДоФрагмента, пПредСтрока, позицияФрагмента, пФрагмент) Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

#Область Скобки

Функция ПривестиСкобкиКНорме(пСтрока)
	
	строкаИзменена = Ложь;
	строкаИзменена = ПривестиОткрывающиесяСкобкиКНорме(пСтрока, "(", ")", ДобавлятьПробелыВнутриСкобок()) ИЛИ строкаИзменена;
	строкаИзменена = ПривестиОткрывающиесяСкобкиКНорме(пСтрока, "[", "]", ДобавлятьПробелыВнутриКвадратныхСкобок()) ИЛИ строкаИзменена;
	строкаИзменена = ПривестиЗакрывающиесяСкобкиКНорме(пСтрока, "(", ")", ДобавлятьПробелыВнутриСкобок()) ИЛИ строкаИзменена;
	строкаИзменена = ПривестиЗакрывающиесяСкобкиКНорме(пСтрока, "[", "]", ДобавлятьПробелыВнутриКвадратныхСкобок()) ИЛИ строкаИзменена;
	
	Возврат строкаИзменена;
	
КонецФункции

Функция ПривестиОткрывающиесяСкобкиКНорме(пСтрока, Знач пОткрывающаяСкобка, Знач пЗакрывающаяСкобка, Знач пДобавлятьПробелы)
	
	Если Не ЗначениеЗаполнено(пСтрока) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат  = "";
	остатокСтроки = пСтрока;
	
	позицияСкобки = ПозицияФрагмента(остатокСтроки, пОткрывающаяСкобка);
	
	Если позицияСкобки = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если пДобавлятьПробелы Тогда
		
		пробел = " ";
		
	Иначе
		
		пробел = "";
		
	КонецЕсли;
	
	Пока Не позицияСкобки = 0 Цикл
		
		строкаПослеСкобки = Сред(остатокСтроки, позицияСкобки + 1);
		строкаДоСкобки    = Лев(остатокСтроки, позицияСкобки - 1);
		
		строкаДоСкобки = УдалитьПробелыПередСкобкой(строкаДоСкобки);
		
		стрРезультат = стрРезультат + строкаДоСкобки + пОткрывающаяСкобка;
		
		остатокСтроки = СокрЛ(строкаПослеСкобки);
		
		Если Не СтрНачинаетсяС(остатокСтроки, пЗакрывающаяСкобка) Тогда
			
			стрРезультат = стрРезультат + пробел;
			
		КонецЕсли;
		
		позицияСкобки = ПозицияФрагмента(остатокСтроки, пОткрывающаяСкобка);
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + остатокСтроки;
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция УдалитьПробелыПередСкобкой(Знач пСтрока)
	
	Если Не СтрЗаканчиваетсяНа(пСтрока, " ") Тогда
		
		Возврат пСтрока;
		
	КонецЕсли;
	
	строкаСокрП = СокрП(пСтрока);
	
	Если ПустаяСтрока(строкаСокрП) Тогда
		
		Возврат пСтрока;
		
	КонецЕсли;
	
	последнийСимвол = Прав(строкаСокрП, 1);
	
	Если ЭтоРазделительСлов(КодСимвола(последнийСимвол)) Тогда
		
		Возврат пСтрока;
		
	КонецЕсли;
	
	Если КодЗаканчиваетсяНа_ОдинИзФрагментов(строкаСокрП, КлючевыеСловаСОбязательнымПробеломПередСкобкой()) Тогда
		
		Возврат пСтрока;
		
	КонецЕсли;
	
	Возврат строкаСокрП;
	
КонецФункции

Функция ПривестиЗакрывающиесяСкобкиКНорме(пСтрока, Знач пОткрывающаяСкобка, Знач пЗакрывающаяСкобка, Знач пДобавлятьПробелы)
	
	Если Не ЗначениеЗаполнено(пСтрока) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат  = "";
	остатокСтроки = пСтрока;
	
	позицияСкобки = ПозицияФрагмента(остатокСтроки, пЗакрывающаяСкобка);
	
	Если позицияСкобки = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если пДобавлятьПробелы Тогда
		
		пробел = " ";
		
	Иначе
		
		пробел = "";
		
	КонецЕсли;
	
	Пока Не позицияСкобки = 0 Цикл
		
		строкаПослеСкобки = Сред(остатокСтроки, позицияСкобки + 1);
		строкаДоСкобки    = СокрП(Лев(остатокСтроки, позицияСкобки - 1));
		
		Если Не СтрЗаканчиваетсяНа(строкаДоСкобки, пОткрывающаяСкобка) Тогда
			
			строкаДоСкобки = строкаДоСкобки + пробел;
			
		КонецЕсли;
		
		стрРезультат = стрРезультат + строкаДоСкобки + пЗакрывающаяСкобка;
		
		остатокСтроки = строкаПослеСкобки;
		
		позицияСкобки = ПозицияФрагмента(остатокСтроки, пЗакрывающаяСкобка);
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + остатокСтроки;
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

#КонецОбласти

Процедура РазвернутьПробелы(пТекстДок, пМассивСтрок, Знач пФрагмент, Знач пВыравнивание)
	
	Если пМассивСтрок.Количество() < 2 Тогда
		
		Возврат;
		
	КонецЕсли;
	
	// Удалим из выравнивания строку с инициализацией строки/запроса
	
	текстПервойСтроки = ВРег(пТекстДок.ПолучитьСтроку(пМассивСтрок[0]));
	текстВторойСтроки = ВРег(пТекстДок.ПолучитьСтроку(пМассивСтрок[1]));
	
	позицияФрагмента = ПозицияФрагмента(текстПервойСтроки, пФрагмент);
	
	левоеВыражение = СокрЛП(Сред(текстПервойСтроки, 1, позицияФрагмента - 1));
	
	Если СтрНачинаетсяС(СокрЛП(текстВторойСтроки), левоеВыражение + ".") Тогда
		
		пМассивСтрок.Удалить(0);
		
	КонецЕсли;
	
	Если пМассивСтрок.Количество() < 2 Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ЕстьИзменения = Истина;
	
	максПозиция = 0;
	
	Для каждого цНомерСтроки Из пМассивСтрок Цикл
		
		текСтрока = пТекстДок.ПолучитьСтроку(цНомерСтроки);
		
		максПозиция = Макс(ПозицияФрагмента(текСтрока, пФрагмент), максПозиция);
		
	КонецЦикла;
	
	размерФрагмента = СтрДлина(пФрагмент);
	
	массивКороткихСтрок = Новый Массив();
	сдвигПревышение     = СдвигПревышение();
	
	Для каждого цНомерСтроки Из пМассивСтрок Цикл
		
		текСтрока = пТекстДок.ПолучитьСтроку(цНомерСтроки);
		
		индексФрагмента = ПозицияФрагмента(текСтрока, пФрагмент);
		
		Если максПозиция - индексФрагмента > сдвигПревышение Тогда
			
			массивКороткихСтрок.Добавить(цНомерСтроки);
			Продолжить;
			
		КонецЕсли;
		
		СтрокаПробелов = СтрокаПробелов(максПозиция - индексФрагмента);
		
		Если пВыравнивание = "Право" Тогда
			
			НоваяСтрока = Лев(текСтрока, индексФрагмента - 1) + СтрокаПробелов + Сред(текСтрока, индексФрагмента);
			
		Иначе
			
			строкаДоПробелов = Лев(текСтрока, индексФрагмента + размерФрагмента - 1);
			строкаПосле      = Сред(текСтрока, индексФрагмента + размерФрагмента);
			
			НоваяСтрока = строкаДоПробелов + СтрокаПробелов + строкаПосле;
			
		КонецЕсли;
		
		пТекстДок.ЗаменитьСтроку(цНомерСтроки, СокрП(НоваяСтрока));
		
	КонецЦикла;
	
	РазвернутьПробелы(пТекстДок, массивКороткихСтрок, пФрагмент, пВыравнивание);
	
	пМассивСтрок = Новый Массив;
	
КонецПроцедуры

Функция УдалитьПробелыСправа(пСтрока)
	
	Если Не ЗначениеЗаполнено(пСтрока) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если пСтрока = СокрП(пСтрока) Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = СокрП(пСтрока);
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция ЭтоУнарнаяОперация(Знач пСтрокаДоФрагмента, Знач пПредСтрока, Знач пПозицияФрагмента, Знач пФрагмент)
	
	Если Не пФрагмент = "-" Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ПустаяСтрока(пСтрокаДоФрагмента) Тогда
		
		пСтрокаДоФрагмента = пПредСтрока;
		
	КонецЕсли;
	
	Возврат КодЗаканчиваетсяНа_ОдинИзФрагментов(пСтрокаДоФрагмента, КлючевыеСловаДляПодтвержденияУнарныхОпераций());
	
КонецФункции

Функция СдвинутьКодПоИнструкциямПрепроцессора(пТекСтрока, пТекущийСдвиг)
	
	этоСтрокаПрепроцессора = Ложь;
	
	Для каждого цСловоНачало Из КлючевыеСловаПрепроцессораНачало() Цикл
		
		Если КодНачинаетсяНа(пТекСтрока, цСловоНачало.Ключ, цСловоНачало.Значение) Тогда
			
			пТекущийСдвиг          = пТекущийСдвиг + 1;
			этоСтрокаПрепроцессора = Истина;
			
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для каждого цСловоНачало Из КлючевыеСловаПрепроцессораКонец() Цикл
		
		Если КодНачинаетсяНа(пТекСтрока, цСловоНачало.Ключ, цСловоНачало.Значение) Тогда
			
			пТекущийСдвиг = пТекущийСдвиг - 1;
			
			Если пТекущийСдвиг < 0 Тогда
				
				пТекущийСдвиг = 0;
				
			КонецЕсли;
			
			этоСтрокаПрепроцессора = Истина;
			
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	строкаИзменена = Ложь;
	
	Если этоСтрокаПрепроцессора Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Для ц = 1 По пТекущийСдвиг Цикл
		
		Если СтрНачинаетсяС(пТекСтрока, "	") Тогда
			
			пТекСтрока     = Сред(пТекСтрока, 2);
			строкаИзменена = Истина;
			
		КонецЕсли;
		
		Если СтрНачинаетсяС(пТекСтрока, "    ") Тогда
			
			пТекСтрока     = Сред(пТекСтрока, 5);
			строкаИзменена = Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат строкаИзменена;
	
КонецФункции

Функция УстановитьОтступПеренесеннымСтрокам(пТекСтрока, Знач предСтрока, этоСерияПеренесенныхВыражений)
	
	Если ЭтоЗавершеннаяСтрокаКода(предСтрока) Тогда
		
		этоСерияПеренесенныхВыражений = Ложь;
		
		Возврат Ложь;
		
	КонецЕсли;
	
	новыйОтступ = СформироватьОтступПеренесеннойСтроке(пТекСтрока, предСтрока, Не этоСерияПеренесенныхВыражений);
	
	этоСерияПеренесенныхВыражений = Истина;
	
	новТекСтрока = новыйОтступ + СокрЛ(пТекСтрока);
	
	Если пТекСтрока = новТекСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пТекСтрока = новТекСтрока;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

// 0 - не добавлять
// 1 - добавить пустую строку после, если у следующей строки не 1
// 2 - добавить пустую строку после
// 3 - добавить пустую строку до
// 4 - добавить пустые строки до и после.
Функция ОкружитьПустымиСтроками(Знач пСтрока)
	
	СТРОКА = ВРег(пСтрока);
	
	текУровень = 0;
	
	Для каждого цЭлемент Из КлючевыеСловаДляДобавленияПустыхСтрок() Цикл
		
		Если ПозицияФрагмента(СТРОКА, цЭлемент.Ключ, Истина) > 0 Тогда
			
			Если цЭлемент.Значение = 4
				ИЛИ(цЭлемент.Значение = 3
				И текУровень = 2)
				ИЛИ(цЭлемент.Значение = 2
				И текУровень = 3) Тогда
				
				текУровень = 4;
				Прервать;
				
			Иначе
				
				текУровень = Макс(текУровень, цЭлемент.Значение);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат текУровень;
	
КонецФункции

Функция ДобавитьПустуюСтрокуДо(Знач пТекСтрока, Знач пПредСтрока)
	
	Если Не ДобавлятьПустыеСтрокиВокругКлючевыхКонструкций() Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ПустаяСтрока(пПредСтрока)
		ИЛИ СтрНачинаетсяС(СокрЛ(пПредСтрока), "//") Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если СтрНачинаетсяС(СокрЛ(пТекСтрока), "//")
		И ДобавлятьПустыеСтрокиПередКомментарием() Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	// Перед директивами компиляции всегда добавляем пустую строку
	Если СтрНачинаетсяС(пТекСтрока, "&На") Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	режимДобавления = ОкружитьПустымиСтроками(пТекСтрока);
	
	Возврат режимДобавления = 4 ИЛИ режимДобавления = 3;
	
КонецФункции

Функция ДобавитьПустуюСтрокуПосле(Знач пТекСтрока, Знач пПредСтрока, пОтложеннаяУстановка)
	
	Если Не ДобавлятьПустыеСтрокиВокругКлючевыхКонструкций() Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ПустаяСтрока(пТекСтрока) Тогда
		
		пОтложеннаяУстановка = Ложь;
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если пОтложеннаяУстановка
		И ЭтоЗавершеннаяСтрокаКода(пПредСтрока) Тогда
		
		пОтложеннаяУстановка = Ложь;
		
		Возврат Истина;
		
	КонецЕсли;
	
	режимДобавления = ОкружитьПустымиСтроками(пПредСтрока);
	
	добавитьПустуюСтроку = Ложь;
	
	Если режимДобавления = 2
		ИЛИ режимДобавления = 4 Тогда
		
		добавитьПустуюСтроку = Истина;
		
	КонецЕсли;
	
	Если режимДобавления = 1
		И Не ОкружитьПустымиСтроками(пТекСтрока) = 1 Тогда
		
		добавитьПустуюСтроку = Истина;
		
	КонецЕсли;
	
	Если добавитьПустуюСтроку Тогда
		
		Если Не ЭтоЗавершеннаяСтрокаКода(пПредСтрока) Тогда
			
			пОтложеннаяУстановка = Истина;
			
			Возврат Ложь;
			
		Иначе
			
			пОтложеннаяУстановка = Ложь;
			
			Возврат Истина;
			
		КонецЕсли;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции

// Режим = 0 - обычный вызов
// режим = 1 - разбивка по запятым
// режим = 2 - разбивка по И/ИЛИ.
Процедура РазбитьДлинныеВыражения(пТекСтрока, строкаИзменена, режим, этоСерияПеренесенныхВыражений)
	
	Если режим = 0 Тогда
		
		позицияКомментария = ПозицияФрагмента(пТекСтрока, "//");
		
		Если Не позицияКомментария = 0
			И позицияКомментария < ОграничениеДлиныСтроки() Тогда
			
			Возврат;
			
		КонецЕсли;
		
		Если СтрДлина(пТекСтрока) < ОграничениеДлиныСтроки() Тогда
			
			Возврат;
			
		КонецЕсли;
		
	КонецЕсли;
	
	пТекСтрока = ТабыВПробелы(пТекСтрока);
	
	отступы       = ПолучитьОтступы(пТекСтрока);
	длинаОтступов = СтрЧислоВхождений(отступы, " ") + 4 * СтрЧислоВхождений(отступы, "	");
	
	списокРазрывов = Новый СписокЗначений;
	
	Если режим = 0 Тогда
		
		позицияЗапятой = ПозицияФрагмента(пТекСтрока, ",", Ложь);
		позицияСкобки  = ПозицияОткрывающейсяСкобки(пТекСтрока);
		
		Если позицияЗапятой < ОграничениеДлиныСтроки()
			ИЛИ позицияСкобки = 0
			ИЛИ позицияСкобки > позицияЗапятой Тогда
			
			списокРазрывов.Добавить(позицияЗапятой, ",");
			
		Иначе
			
			списокРазрывов.Добавить(позицияСкобки, "(");
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если режим = 1 Тогда
		
		списокРазрывов.Добавить(ПозицияФрагмента(пТекСтрока, ",", Ложь), ",");
		списокРазрывов.Добавить(ПозицияОткрывающейсяСкобки(пТекСтрока), "(");
		
	КонецЕсли;
	
	Если режим = 0
		ИЛИ режим = 2 Тогда
		
		списокРазрывов.Добавить(ПозицияРазрыва(пТекСтрока, "И", Истина), "И");
		списокРазрывов.Добавить(ПозицияРазрыва(пТекСтрока, "ИЛИ", Истина), "ИЛИ");
		
	КонецЕсли;
	
	списокРазрывов.СортироватьПоЗначению(НаправлениеСортировки.Возр);
	
	Для каждого цРазрыв Из списокРазрывов Цикл
		
		Если цРазрыв.Значение = 0 Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		Если цРазрыв.Представление = ","
			ИЛИ цРазрыв.Представление = "(" Тогда
			
			позицияРазрыва = цРазрыв.Значение - 1 + СтрДлина(цРазрыв.Представление);
			
			строкаДоРазрыва    = СокрП(Лев(пТекСтрока, позицияРазрыва));
			строкаПослеРазрыва = СокрЛ(Сред(пТекСтрока, позицияРазрыва + 1));
			
			новРежим = 1;
			
		Иначе
			
			позицияРазрыва = цРазрыв.Значение - 1;
			
			строкаДоРазрыва    = СокрП(Лев(пТекСтрока, позицияРазрыва - 1));
			строкаПослеРазрыва = СокрЛ(Сред(пТекСтрока, позицияРазрыва));
			
			новРежим = 2;
			
		КонецЕсли;
		
		Если ПустаяСтрока(строкаПослеРазрыва) Тогда
			
			этоСерияПеренесенныхВыражений = Истина;
			
			Возврат;
			
		КонецЕсли;
		
		новыйОтступ = СформироватьОтступПеренесеннойСтроке(строкаПослеРазрыва, строкаДоРазрыва, режим = 0);
		
		пТекСтрока = новыйОтступ + строкаПослеРазрыва;
		
		строкаИзменена = Истина;
		ДобавитьВРезультат(строкаДоРазрыва);
		
		РазбитьДлинныеВыражения(пТекСтрока, строкаИзменена, новРежим, этоСерияПеренесенныхВыражений);
		
		Возврат;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура РазбитьВыраженияПоПереносам(пТекСтрока, строкаИзменена)
	
	кодБезКомментариев = СокрП(КодБезКомментариев(пТекСтрока));
	
	Если ПустаяСтрока(кодБезКомментариев) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	позицияРазрыва  = СтрДлина(кодБезКомментариев) + 1;
	фрагментРазрыва = "";
	исхПозиция      = позицияРазрыва;
	
	словаЗавершения = КлючевыеСловаЗавершения();
	
	Если КодНачинаетсяНа(пТекСтрока, "Перем", Истина) Тогда
		
		словаЗавершения.Удалить("ЭКСПОРТ");
		словаЗавершения.Удалить("EXPORT");
		
		словаЗавершения.Вставить("ЭКСПОРТ;", Истина);
		словаЗавершения.Вставить("EXPORT;", Истина);
		
	КонецЕсли;
	
	Для каждого цЭлемент Из словаЗавершения Цикл
		
		фрагмент    = цЭлемент.Ключ;
		искатьСлово = цЭлемент.Значение;
		
		найденнаяПозиция = ПозицияРазрыва(кодБезКомментариев, фрагмент, искатьСлово);
		
		Если Не найденнаяПозиция = 0
			И Не ПустаяСтрока(Лев(кодБезКомментариев, найденнаяПозиция - 1)) Тогда
			
			позицияФрагмента = найденнаяПозиция + СтрДлина(фрагмент);
			
			Если позицияФрагмента < позицияРазрыва Тогда
				
				фрагментРазрыва = фрагмент;
				позицияРазрыва  = позицияФрагмента;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для каждого цЭлемент Из КлючевыеСловаНачала() Цикл
		
		фрагмент    = цЭлемент.Ключ;
		искатьСлово = цЭлемент.Значение;
		
		позицияФрагмента = ПозицияРазрыва(кодБезКомментариев, фрагмент, искатьСлово);
		
		Если позицияФрагмента > 1
			И Не ПустаяСтрока(Лев(кодБезКомментариев, позицияФрагмента - 1)) Тогда
			
			Если позицияФрагмента < позицияРазрыва Тогда
				
				фрагментРазрыва = фрагмент;
				позицияРазрыва  = позицияФрагмента;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если позицияРазрыва = исхПозиция Тогда
		
		Возврат;
		
	КонецЕсли;
	
	строкаДоРазрыва    = СокрП(Лев(пТекСтрока, позицияРазрыва - 1));
	строкаПослеРазрыва = СокрЛ(Сред(пТекСтрока, позицияРазрыва));
	
	новыйОтступ = ПолучитьОтступы(пТекСтрока);
	
	Если СтрокаКодаУвеличенияОтступа(строкаДоРазрыва) Тогда
		
		новыйОтступ = УвеличитьОтступ(новыйОтступ);
		
	КонецЕсли;
	
	Если СтрокаКодаУменьшенияОтступа(строкаПослеРазрыва) Тогда
		
		новыйОтступ = УменьшитьОтступ(новыйОтступ);
		
	КонецЕсли;
	
	пТекСтрока = новыйОтступ + строкаПослеРазрыва;
	
	строкаИзменена = Истина;
	ДобавитьВРезультат(строкаДоРазрыва);
	
	РазбитьВыраженияПоПереносам(пТекСтрока, строкаИзменена);
	
КонецПроцедуры

Функция УвеличитьОтступ(текущийОтступ)
	
	Возврат ПробелыВТабы(текущийОтступ + "	");
	
КонецФункции

Функция УменьшитьОтступ(текущийОтступ)
	
	отступы       = ТабыВПробелы(текущийОтступ);
	длинаОтступов = СтрДлина(отступы);
	длинаОтступов = Макс(0, длинаОтступов - 4);
	
	Возврат ПробелыВТабы(СтрокаПробелов(длинаОтступов));
	
КонецФункции

Функция СформироватьОтступПеренесеннойСтроке(Знач пТекСтрока,
											 Знач пПредСтрока,
											 Знач пЭтоПерваяСтрокаВВыравнивании = Ложь)
											 
	исхОтступы    = ПолучитьОтступы(пПредСтрока);
	отступы       = ТабыВПробелы(исхОтступы);
	пПредСтрока   = отступы + СокрЛ(пПредСтрока);
	длинаОтступов = СтрДлина(отступы);
	
	новыйОтступ = "";
	
	Если КодЗаканчиваетсяНа(пПредСтрока, ",") Тогда
		
		// Найдем открывающуюся скобку, по которой можно выровнять следующую строку
		
		позицияСкобки = ПозицияОткрывающейсяСкобки(пПредСтрока);
		
		Если КодЧислоВхождений(пПредСтрока, "(") <= КодЧислоВхождений(пПредСтрока, ")") Тогда
			
			позицияСкобки = 0;
			
		КонецЕсли;
		
		количествоПробелов = 0;
		
		Если позицияСкобки > 0 Тогда
			
			строкаПослеСкобки = Сред(пПредСтрока, позицияСкобки + 1);
			
			сдвигЗнач = ПолучитьСдвигЗнач(пТекСтрока, строкаПослеСкобки);
			
			Если ДобавлятьПробелыВнутриСкобок() Тогда
				
				позицияСкобки = позицияСкобки + 1;
				
			КонецЕсли;
			
			количествоПробелов = позицияСкобки - длинаОтступов + сдвигЗнач;
			
		ИначеЕсли пЭтоПерваяСтрокаВВыравнивании Тогда
			
			количествоПробелов = 4;
			
		Иначе
			
			сдвигЗнач          = ПолучитьСдвигЗнач(пТекСтрока, пПредСтрока);
			количествоПробелов = сдвигЗнач;
			
		КонецЕсли;
		
		Если ПозицияЗакрывающейсяСкобки(пПредСтрока) > 0
			И КодЧислоВхождений(пПредСтрока, "(") < КодЧислоВхождений(пПредСтрока, ")") Тогда
			
			количествоПробелов = количествоПробелов - 4;
			
		КонецЕсли;
		
		строкаПробелов = СтрокаПробелов(длинаОтступов + количествоПробелов);
		новыйОтступ    = ПробелыВТабы(строкаПробелов);
		
	ИначеЕсли КодНачинаетсяНа(пТекСтрока, "И", Истина)
		ИЛИ КодНачинаетсяНа(пТекСтрока, "ИЛИ", Истина) Тогда
		
		Если пЭтоПерваяСтрокаВВыравнивании Тогда
			
			строкаПробелов = "	";
			
		Иначе
			
			строкаПробелов = "";
			
		КонецЕсли;
		
		новыйОтступ = ПробелыВТабы(отступы + строкаПробелов);
		
	ИначеЕсли (КодНачинаетсяНа(пПредСтрока, "|")
		ИЛИ КодНачинаетсяНа(пПредСтрока, """"))
		И КодНачинаетсяНа(пТекСтрока, "|") Тогда
		
		новыйОтступ = ПробелыВТабы(отступы + "");
		
	ИначеЕсли (КодНачинаетсяНа(пТекСтрока, "|")
		ИЛИ КодНачинаетсяНа(пТекСтрока, """"))
		И Не КодНачинаетсяНа(пПредСтрока, """") Тогда
		
		режимПереносаСтрок = РежимВыравниванияТекстов();
		
		Если режимПереносаСтрок = 0 Тогда
			
			новыйОтступ = ПробелыВТабы(отступы + "");
			
		ИначеЕсли режимПереносаСтрок = 1 Тогда
			
			новыйОтступ = ПробелыВТабы(отступы + "	");
			
		ИначеЕсли режимПереносаСтрок = 2 Тогда
			
			позицияСкобки = ПозицияОткрывающейсяСкобки(пПредСтрока);
			позицияРавно  = ПозицияФрагмента(пПредСтрока, "=");
			
			Если позицияРавно = 0
				И позицияСкобки = 0 Тогда
				
				позицияВыравнивания = 0;
				
			ИначеЕсли (позицияРавно > 0
				И позицияСкобки > позицияРавно)
				ИЛИ позицияСкобки = 0 Тогда
				
				позицияВыравнивания = позицияРавно;
				
			Иначе
				
				позицияВыравнивания = позицияСкобки;
				
			КонецЕсли;
			
			Если позицияВыравнивания < ОграничениеСдвига()
				И позицияВыравнивания > 0 Тогда
				
				количествоПробелов = позицияВыравнивания - длинаОтступов;
				строкаПробелов     = СтрокаПробелов(длинаОтступов + количествоПробелов + 1);
				новыйОтступ        = ПробелыВТабы(строкаПробелов);
				
			Иначе
				
				новыйОтступ = ПробелыВТабы(отступы + "	");
				
			КонецЕсли;
			
		КонецЕсли;
		
	ИначеЕсли КодЗаканчиваетсяНа(пПредСтрока, "=") Тогда
		
		Если СтрДлина(ТабыВПробелы(пПредСтрока)) < ОграничениеСдвига() Тогда
			
			строкаПробелов = СтрокаПробелов(СтрДлина(пПредСтрока) - длинаОтступов + 1);
			
			новыйОтступ = ПробелыВТабы(отступы + строкаПробелов);
			
		Иначе
			
			новыйОтступ = ПробелыВТабы(отступы + "	");
			
		КонецЕсли;
		
	ИначеЕсли КодЗаканчиваетсяНа(пПредСтрока, "(")
		ИЛИ пЭтоПерваяСтрокаВВыравнивании Тогда
		
		новыйОтступ = ПробелыВТабы(отступы + "	");
		
	Иначе
		
		новыйОтступ = отступы;
		
	КонецЕсли;
	
	Если ИспользоватьПробелыДляВыравнивания() Тогда
		
		// вернем исходные табы в начало
		
		исхОтступы         = СтрЗаменить(исхОтступы, " ", "");
		количествоТабов    = СтрЧислоВхождений(исхОтступы, "	");
		количествоПробелов = количествоТабов * 4;
		новыйОтступ        = ТабыВПробелы(новыйОтступ);
		
		Если СтрДлина(новыйОтступ) > количествоПробелов
			И количествоПробелов > 0 Тогда
			
			новыйОтступ = исхОтступы + Сред(новыйОтступ, количествоПробелов + 1);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат новыйОтступ;
	
КонецФункции

Функция ПолучитьСдвигЗнач(Знач пТекСтрока, Знач строкаПослеСкобки)
	
	сдвигЗнач   = 0;
	длинаСдвига = 5;
	
	Если СтрНачинаетсяС(СокрЛ(ВРег(строкаПослеСкобки)), ВРег("Знач ")) Тогда
		
		сдвигЗнач = сдвигЗнач + длинаСдвига;
		
	КонецЕсли;
	
	Если СтрНачинаетсяС(СокрЛ(ВРег(пТекСтрока)), ВРег("Знач ")) Тогда
		
		сдвигЗнач = сдвигЗнач - длинаСдвига;
		
	КонецЕсли;
	
	Возврат сдвигЗнач;
	
КонецФункции

ЕстьИзменения      = Ложь;
кэшРазделителиСлов = Новый Соответствие;

Настройки = Новый Соответствие;

