
Перем Настройки Экспорт;

Перем ЕстьИзменения;
Перем кэшРазделителиСлов;

Перем мНовыйКод;
Перем мНовыйКодИзменен;
Перем мТекПустыхСтрок;
Перем мМаксПустыхСтрок;

// Выравнивает код по установленным фрагментам
//
// Параметры:
//  ИсходныйКод  - ТабличныйДокумент - Код для выравнивания.
//
// Возвращаемое значение:
//   Булево   - Есть изменения
//
Функция ВыровнитьКод( ИсходныйКод ) Экспорт
	
	ЕстьИзменения = Ложь;
	
	ФорматироватьПереносы( ИсходныйКод );
	
	// Выравнивание по фрагментам
	
	Для каждого цФрагмент Из ФрагментыВыравнивания() Цикл
		
		ВыровнитьКодПоФрагменту( ИсходныйКод, цФрагмент );
		
	КонецЦикла;
	
	Возврат ЕстьИзменения;
	
КонецФункции

Процедура ФорматироватьПереносы( пИсходныйКод )
	
	мНовыйКодИзменен = Ложь;
	
	мНовыйКод        = Новый ТекстовыйДокумент;
	мМаксПустыхСтрок = МаксПустыхСтрок();
	мТекПустыхСтрок  = 0;
	предСтрока       = "";
	отложеннаяУстановкаПустойСтроки = Ложь;
	этоСерияПеренесенныхВыражений   = Ложь;
	удалитьТабов     = 0;
	
	Для цНомерСтроки = 1 По пИсходныйКод.КоличествоСтрок() Цикл
		
		цТекСтрока     = пИсходныйКод.ПолучитьСтроку( цНомерСтроки );
		строкаИзменена = Ложь;
		
		строкаИзменена = СдвинутьКодПоИнструкциямПрепроцессора( цТекСтрока, удалитьТабов ) ИЛИ строкаИзменена;
		
		Если ДобавитьПустуюСтрокуПосле( цТекСтрока, предСтрока, отложеннаяУстановкаПустойСтроки ) Тогда
			
			отступы = ПолучитьОтступы( цТекСтрока );
			ДобавитьВРезультат( отступы );
			мНовыйКодИзменен = Истина;
			предСтрока       = отступы;
			
		КонецЕсли;
		
		Если ДобавитьПустуюСтрокуДо( цТекСтрока, предСтрока ) Тогда
			
			ДобавитьВРезультат( ПолучитьОтступы( предСтрока ) );
			мНовыйКодИзменен = Истина;
			
		КонецЕсли;
		
		строкаИзменена = УдалитьЛишниеПробельныеСимволы( цТекСтрока ) ИЛИ строкаИзменена;
		строкаИзменена = ПривестиЗапятыеКНорме( цТекСтрока ) ИЛИ строкаИзменена;
		
		Для каждого цЗнак Из АрифметическиеЗнаки() Цикл
			
			строкаИзменена = ПривестиАрифметическиеЗнакиКНорме( цТекСтрока, цЗнак, предСтрока ) ИЛИ строкаИзменена;
			
		КонецЦикла;
		
		строкаИзменена = ПривестиЗнакиРавноКНорме( цТекСтрока ) ИЛИ строкаИзменена;
		строкаИзменена = ПривестиОткрывающиесяСкобкиКНорме( цТекСтрока ) ИЛИ строкаИзменена;
		строкаИзменена = ПривестиЗакрывающиесяСкобкиКНорме( цТекСтрока ) ИЛИ строкаИзменена;
		строкаИзменена = УдалитьПробелыСправа( цТекСтрока ) ИЛИ строкаИзменена;
		
		строкаИзменена = УстановитьОтступПеренесеннымСтрокам( цТекСтрока,
															  предСтрока,
															  этоСерияПеренесенныхВыражений ) ИЛИ строкаИзменена;
		
		РазбитьДлинныеВыражения( цТекСтрока, строкаИзменена, 0, этоСерияПеренесенныхВыражений );
		
		Если строкаИзменена Тогда
			
			мНовыйКодИзменен = Истина;
			
		КонецЕсли;
		
		ДобавитьВРезультат( цТекСтрока );
		предСтрока = цТекСтрока;
		
	КонецЦикла;
	
	Если мНовыйКодИзменен Тогда
		
		ЕстьИзменения = Истина;
		пИсходныйКод  = мНовыйКод;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьВРезультат( Знач пСтрока )
	
	Если ПустаяСтрока( пСтрока ) Тогда
		
		мТекПустыхСтрок = мТекПустыхСтрок + 1;
		
	Иначе
		
		мТекПустыхСтрок = 0;
		
	КонецЕсли;
	
	Если Не ПустаяСтрока( пСтрока )
		ИЛИ мТекПустыхСтрок <= мМаксПустыхСтрок Тогда
		
		мНовыйКод.ДобавитьСтроку( пСтрока );
		
	Иначе
		
		мНовыйКодИзменен = Истина;
		
	КонецЕсли;
	
КонецПроцедуры


Функция ПолучитьНастройку( Знач пИмя, Знач пЗначениеПоУмолчанию )
	
	значениеНастройки = Настройки[пИмя];
	
	Если значениеНастройки = Неопределено Тогда
		
		значениеНастройки = пЗначениеПоУмолчанию;
		
	КонецЕсли;
	
	Возврат значениеНастройки;
	
КонецФункции

Функция СдвигПревышение()
	
	Возврат ПолучитьНастройку( "СдвигПревышение", 12 );
	
КонецФункции

// Если перенесенное выражение будет иметь сдвиг больше, то сдвиг будет рассчитан иначе.
Функция ОграничениеСдвига()
	
	Возврат 20;
	
КонецФункции

Функция ДобавлятьПробелыВнутриСкобок()
	
	Возврат ПолучитьНастройку( "ДобавлятьПробелыВнутриСкобок", Истина );
	
КонецФункции

Функция ОграничениеДлиныСтроки()
	
	Возврат ПолучитьНастройку( "ОграничениеДлиныСтроки", 120 );
	
КонецФункции

Функция ДобавлятьПустыеСтрокиПередКомментарием()
	
	Возврат ПолучитьНастройку( "ДобавлятьПустыеСтрокиПередКомментарием", Истина );
	
КонецФункции

Функция ДобавлятьПустыеСтрокиВокругКлючевыхКонструкций()
	
	Возврат ПолучитьНастройку( "ДобавлятьПустыеСтрокиВокругКлючевыхКонструкций", Истина );
	
КонецФункции

Функция МаксПустыхСтрок()
	
	Возврат ПолучитьНастройку( "МаксПустыхСтрок", 3 );
	
КонецФункции


Функция ИспользоватьПробелыДляВыравнивания()
	
	Возврат ПолучитьНастройку( "ИспользоватьПробелыДляВыравнивания", Ложь );
	
КонецФункции

// 0 - не выравнивать
// 1 - добавлять таб
// 2 - выравнивать по равно/скобке.
Функция РежимВыравниванияТекстов()
	
	Возврат ПолучитьНастройку( "РежимВыравниванияТекстов", 0 );
	
КонецФункции

Функция ВыравниватьПоРавно()
	
	Возврат ПолучитьНастройку( "ВыравниватьПоРавно", Истина );
	
КонецФункции

Функция ВыравниватьПоСкобке()
	
	Возврат ПолучитьНастройку( "ВыравниватьПоСкобке", Истина );
	
КонецФункции

Функция ВыравниватьПоЗапятой()
	
	Возврат ПолучитьНастройку( "ВыравниватьПоЗапятой", Истина );
	
КонецФункции

Функция ВыравниватьПоКомментариям()
	
	Возврат ПолучитьНастройку( "ВыравниватьПоКомментариям", Истина );
	
КонецФункции

Функция ФрагментыВыравнивания()
	
	фрагментыВыравнивания = Новый СписокЗначений;
	
	Если ВыравниватьПоРавно() Тогда
		
		фрагментыВыравнивания.Добавить( "=", "Право" );
		
	КонецЕсли;
	
	Если ВыравниватьПоСкобке() Тогда
		
		фрагментыВыравнивания.Добавить( "(", "Лево" );
		
	КонецЕсли;
	
	Если ВыравниватьПоЗапятой() Тогда
		
		фрагментыВыравнивания.Добавить( ",", "Лево" );
		
	КонецЕсли;
	
	Если ВыравниватьПоКомментариям() Тогда
		
		фрагментыВыравнивания.Добавить( "//", "Право" );
		
	КонецЕсли;
	
	Возврат фрагментыВыравнивания;
	
КонецФункции


Функция АрифметическиеЗнаки()
	
	Возврат СтрРазделить( "<=,>=,<>,+,-,<,>", "," );
	
КонецФункции

Функция КлючевыеСловаПрепроцессораНачало()
	
	слова = Новый Соответствие;
	
	слова.Вставить( "#ЕСЛИ", Истина );
	слова.Вставить( "#ИНАЧЕЕСЛИ", Истина );
	слова.Вставить( "#ИНАЧЕ", Истина );
	
	Возврат слова;
	
КонецФункции

Функция КлючевыеСловаПрепроцессораКонец()
	
	слова = Новый Соответствие;
	
	слова.Вставить( "#КОНЕЦЕСЛИ", Истина );
	
	Возврат слова;
	
КонецФункции

Функция КлючевыеСловаОбласть()
	
	слова = Новый Соответствие;
	
	слова.Вставить( "#ОБЛАСТЬ", Истина );
	слова.Вставить( "#КОНЕЦОБЛАСТИ", Истина );
	
	Возврат слова;
	
КонецФункции


Функция РазделителиБлоков()
	
	РазделителиБлоков = Новый Соответствие;
	РазделителиБлоков.Вставить( "ЕСЛИ", Истина );
	РазделителиБлоков.Вставить( "ИНАЧЕЕСЛИ", Истина );
	РазделителиБлоков.Вставить( "КОНЕЦЕСЛИ", Истина );
	РазделителиБлоков.Вставить( "ТОГДА", Истина );
	РазделителиБлоков.Вставить( "И", Истина );
	РазделителиБлоков.Вставить( "ИЛИ", Истина );
	РазделителиБлоков.Вставить( "НЕ", Истина );
	РазделителиБлоков.Вставить( "ИЗ", Истина );
	РазделителиБлоков.Вставить( "ДЛЯ", Истина );
	РазделителиБлоков.Вставить( "КАЖДОГО", Истина );
	РазделителиБлоков.Вставить( "ПО", Истина );
	РазделителиБлоков.Вставить( "ЦИКЛ", Истина );
	РазделителиБлоков.Вставить( "ПОКА", Истина );
	РазделителиБлоков.Вставить( "ПРОЦЕДУРА", Истина );
	РазделителиБлоков.Вставить( "ФУНКЦИЯ", Истина );
	РазделителиБлоков.Вставить( "КОНЕЦПРОЦЕДУРЫ", Истина );
	РазделителиБлоков.Вставить( "КОНЕЦФУНКЦИИ", Истина );
	РазделителиБлоков.Вставить( "ЭКСПОРТ", Истина );
	РазделителиБлоков.Вставить( "ПЕРЕМ", Истина );
	РазделителиБлоков.Вставить( "ЗНАЧ", Истина );
	РазделителиБлоков.Вставить( "ПЕРЕЙТИ", Истина );
	РазделителиБлоков.Вставить( "ВЫЗВАТЬИСКЛЮЧЕНИЕ", Истина );
	РазделителиБлоков.Вставить( "ПОПЫТКА", Истина );
	РазделителиБлоков.Вставить( "ИСКЛЮЧЕНИЕ", Истина );
	РазделителиБлоков.Вставить( "КОНЕЦПОПЫТКИ", Истина );
	РазделителиБлоков.Вставить( "ВОЗВРАТ", Истина );
	
	Для каждого цСлово Из КлючевыеСловаПрепроцессораНачало() Цикл
		
		РазделителиБлоков.Вставить( цСлово.Ключ, цСлово.Значение );
		
	КонецЦикла;
	
	Для каждого цСлово Из КлючевыеСловаПрепроцессораКонец() Цикл
		
		РазделителиБлоков.Вставить( цСлово.Ключ, цСлово.Значение );
		
	КонецЦикла;
	
	Возврат РазделителиБлоков;
	
КонецФункции

// Слова, после которых должна быть пустая строка
// 0 - не добавлять
// 1 - добавить пустую строку после, если у следующей строки не 1
// 2 - добавить пустую строку после
// 3 - добавить пустую строку до
// 4 - добавить пустые строки до и после.
Функция КлючевыеСловаДляДобавленияПустыхСтрок()
	
	Слова = Новый Соответствие;
	Слова.Вставить( "ФУНКЦИЯ", 2 );
	Слова.Вставить( "ПРОЦЕДУРА", 2 );
	Слова.Вставить( "КОНЕЦЕСЛИ", 4 );
	Слова.Вставить( "КОНЕЦЦИКЛА", 4 );
	Слова.Вставить( "ДЛЯ", 3 );
	Слова.Вставить( "ПОКА", 3 );
	Слова.Вставить( "ЦИКЛ", 4 );
	Слова.Вставить( "ЕСЛИ", 3 );
	Слова.Вставить( "ТОГДА", 2 );
	Слова.Вставить( "ИНАЧЕ", 4 );
	Слова.Вставить( "#ЕСЛИ", 4 );
	Слова.Вставить( "ИНАЧЕЕСЛИ", 3 );
	Слова.Вставить( "#ИНАЧЕ", 4 );
	Слова.Вставить( "#ИНАЧЕЕСЛИ", 3 );
	Слова.Вставить( "#КОНЕЦЕСЛИ", 4 );
	Слова.Вставить( "#КОНЕЦОБЛАСТИ", 4 );
	Слова.Вставить( "КОНЕЦПРОЦЕДУРЫ", 4 );
	Слова.Вставить( "КОНЕЦФУНКЦИИ", 4 );
	Слова.Вставить( "ЭКСПОРТ", 2 );
	Слова.Вставить( "КОНЕЦПОПЫТКИ", 2 );
	Слова.Вставить( "ВОЗВРАТ", 4 );
	
	Возврат Слова;
	
КонецФункции

Функция КлючевыеСловаЗавершения()
	
	словаЗавершения = Новый Соответствие;
	
	словаЗавершения.Вставить( ";", Ложь );
	словаЗавершения.Вставить( "ТОГДА", Истина );
	словаЗавершения.Вставить( "ИНАЧЕ", Истина );
	словаЗавершения.Вставить( "ЦИКЛ", Истина );
	словаЗавершения.Вставить( "КОНЕЦПРОЦЕДУРЫ", Истина );
	словаЗавершения.Вставить( "КОНЕЦФУНКЦИИ", Истина );
	словаЗавершения.Вставить( "ЭКСПОРТ", Истина );
	
	Возврат словаЗавершения;
	
КонецФункции

Функция КлючевыеСловаДляУвеличенияОтступов()
	
	словаЗавершения = Новый Соответствие;
	
	словаЗавершения.Вставить( "ФУНКЦИЯ", Истина );
	словаЗавершения.Вставить( "ПРОЦЕДУРА", Истина );
	словаЗавершения.Вставить( "ДЛЯ", Истина );
	словаЗавершения.Вставить( "ПОКА", Истина );
	словаЗавершения.Вставить( "ЕСЛИ", Истина );
	словаЗавершения.Вставить( "ИНАЧЕ", Истина );
	словаЗавершения.Вставить( "ИНАЧЕЕСЛИ", Истина );
	словаЗавершения.Вставить( "ПОПЫТКА", Истина );
	словаЗавершения.Вставить( "ИСКЛЮЧЕНИЕ", Истина );
	
	Возврат словаЗавершения;
	
КонецФункции // КлючевыеСловаДляСвдиговОтступов()

Функция КлючевыеСловаДляИсключенияПеременных()
	
	слова = РазделителиБлоков();
	
	слова.Вставить( ";", Ложь );
	слова.Вставить( ",", Ложь );
	слова.Вставить( "%", Ложь );
	слова.Вставить( ":", Ложь );
	слова.Вставить( "(", Ложь );
	слова.Вставить( ")", Ложь );
	слова.Вставить( "=", Ложь );
	слова.Вставить( "/", Ложь );
	слова.Вставить( "*", Ложь );
	слова.Вставить( "+", Ложь );
	слова.Вставить( "-", Ложь );
	
	Возврат слова;
	
КонецФункции


Функция ПозицияФрагмента( Знач пСтрока, Знач пФрагмент, Знач ИскатьОтдельноеСлово = Ложь )
	
	позицияФрагмента = СтрНайти( пСтрока, пФрагмент );
	
	Если ИскатьОтдельноеСлово Тогда
		
		Пока Не позицияФрагмента = 0 Цикл
			
			Если ЭтоОтдельноеСлово( пФрагмент, пСтрока, позицияФрагмента ) Тогда
				
				Прервать;
				
			КонецЕсли;
			
			Если позицияФрагмента = СтрДлина( пСтрока ) Тогда
				
				позицияФрагмента = 0;
				Прервать;
				
			КонецЕсли;
			
			позицияФрагмента = СтрНайти( пСтрока, пФрагмент, , позицияФрагмента + 1 );
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если позицияФрагмента = 0 Тогда
		
		Возврат 0;
		
	КонецЕсли;
	
	Если Не пФрагмент = "//" Тогда
		
		ПозицияКомментария = ПозицияФрагмента( пСтрока, "//" );
		
		Если ПозицияКомментария > 0
			И ПозицияКомментария < позицияФрагмента Тогда
			
			Возврат 0;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ПозицияКавычек = СтрНайти( пСтрока, """" );
	
	// Проверяем есть ли вначале строки символ "|".
	ПервыйСимвол = Сред( СокрЛП( пСтрока ), 1, 1 );
	
	Если пФрагмент = "|"
		И ПервыйСимвол = "|" Тогда
		
		Возврат позицияФрагмента;
		
	КонецЕсли;
	
	// Нет кавычек, оставляем весь комментарий.
	// Кавычки после комментария, оставляем весь комментарий.
	
	Если ( ПозицияКавычек = 0 ИЛИ ПозицияКавычек > позицияФрагмента )
		И ПервыйСимвол <> "|" Тогда
		
		Возврат позицияФрагмента;
		
	ИначеЕсли ПервыйСимвол = "|"
		И ПозицияКавычек = 0 Тогда
		
		// Все в строке
		
		Возврат 0;
		
	ИначеЕсли ПервыйСимвол = "|"
		И ПозицияКавычек > 0 Тогда
		
		строкаПослеКавычек = Сред( пСтрока, ПозицияКавычек + 1 );
		
		позицияФрагмента = ПозицияФрагмента( строкаПослеКавычек, пФрагмент );
		
		Если позицияФрагмента = 0 Тогда
			
			Возврат 0;
			
		Иначе
			
			Возврат ПозицияКавычек + позицияФрагмента;
			
		КонецЕсли;
		
	Иначе
		
		строкаПослеКавычек = "|" + Сред( пСтрока, ПозицияКавычек + 1 );
		
		позицияФрагмента = ПозицияФрагмента( строкаПослеКавычек, пФрагмент );
		
		Если позицияФрагмента = 0 Тогда
			
			Возврат 0;
			
		Иначе
			
			Возврат ПозицияКавычек + позицияФрагмента - 1;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

Функция ПозицияОткрывающейсяСкобки( Знач пСтрока )
	
	позицияСкобки     = ПозицияФрагмента( пСтрока, "(" );
	сдвигПоискаСкобки = 0;
	
	Пока Не позицияСкобки = 0 Цикл
		
		строкаПослеСкобки = Сред( пСтрока, позицияСкобки + 1 );
		
		Если Не СтрНачинаетсяС( СокрЛ( строкаПослеСкобки ), ")" ) Тогда
			
			Прервать;
			
		КонецЕсли;
		
		сдвигПоискаСкобки = сдвигПоискаСкобки + позицияСкобки + 1;
		позицияСкобки     = ПозицияФрагмента( строкаПослеСкобки, "(" );
		
	КонецЦикла;
	
	Если позицияСкобки > 0 Тогда
		
		позицияСкобки = позицияСкобки + сдвигПоискаСкобки;
		
	КонецЕсли;
	
	Возврат позицияСкобки;
	
КонецФункции

Функция ПозицияЗакрывающейсяСкобки( Знач пСтрока )
	
	позицияСкобки     = ПозицияФрагмента( пСтрока, ")" );
	сдвигПоискаСкобки = 0;
	
	Пока Не позицияСкобки = 0 Цикл
		
		строкаДоСкобки    = Лев( пСтрока, позицияСкобки - 1 );
		строкаПослеСкобки = Сред( пСтрока, позицияСкобки + 1 );
		
		Если Не СтрЗаканчиваетсяНа( СокрП( строкаДоСкобки ), "(" ) Тогда
			
			Прервать;
			
		КонецЕсли;
		
		сдвигПоискаСкобки = сдвигПоискаСкобки + позицияСкобки + 1;
		позицияСкобки     = ПозицияФрагмента( строкаПослеСкобки, "(" );
		
	КонецЦикла;
	
	Если позицияСкобки > 0 Тогда
		
		позицияСкобки = позицияСкобки + сдвигПоискаСкобки;
		
	КонецЕсли;
	
	Возврат позицияСкобки;
	
КонецФункции

Функция ПозицияРазрыва( Знач пТекСтрока, Знач пФрагмент, Знач пИскатьОтдельноеСлово = Ложь )
	
	ТЕКСТРОКА = ВРег( пТекСтрока );
	ФРАГМЕНТ  = ВРег( пФрагмент );
	
	Если СтрНачинаетсяС( СокрЛ( ТЕКСТРОКА ), ФРАГМЕНТ ) Тогда
		
		первоеУпоминание = ПозицияФрагмента( ТЕКСТРОКА, ФРАГМЕНТ, пИскатьОтдельноеСлово );
		новСтрокаПоиска  = Сред( ТЕКСТРОКА, первоеУпоминание + СтрДлина( ФРАГМЕНТ ) );
		позицияФрагмента = ПозицияФрагмента( новСтрокаПоиска, ФРАГМЕНТ, пИскатьОтдельноеСлово );
		
		Если позицияФрагмента > 0 Тогда
			
			позицияФрагмента = позицияФрагмента + первоеУпоминание;
			
		КонецЕсли;
		
	Иначе
		
		позицияФрагмента = ПозицияФрагмента( ТЕКСТРОКА, ФРАГМЕНТ, пИскатьОтдельноеСлово );
		
	КонецЕсли;
	
	Возврат позицияФрагмента;
	
КонецФункции


Функция ПолучитьОтступы( Знач пСтрока )
	
	количествоОтступов = СтрДлина( пСтрока );
	
	Для ц = 1 По СтрДлина( пСтрока ) Цикл
		
		Если Не ПустаяСтрока( Сред( пСтрока, ц, 1 ) ) Тогда
			
			количествоОтступов = ц - 1;
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Лев( пСтрока, количествоОтступов );
	
КонецФункции

Функция ПробелыВТабы( Знач пСтрока )
	
	Если ИспользоватьПробелыДляВыравнивания() Тогда
		
		Возврат пСтрока;
		
	Иначе
		
		стрРезультат = СтрЗаменить( пСтрока, "    ", "	" );
		
		Возврат стрРезультат;
		
	КонецЕсли;
	
КонецФункции

Функция ТабыВПробелы( Знач пСтрока )
	
	Возврат СтрЗаменить( пСтрока, "	", "    " );
	
КонецФункции


Функция КодБезКомментариев( Знач пСтрока )
	
	ПозицияКомментария = ПозицияФрагмента( пСтрока, "//" );
	
	Если ПозицияКомментария = 0 Тогда
		
		Возврат пСтрока;
		
	Иначе
		
		Возврат Лев( пСтрока, ПозицияКомментария - 1 );
		
	КонецЕсли;
	
КонецФункции

Функция ЭтоЗавершеннаяСтрокаКода( Знач пСтрока )
	
	Если ПустаяСтрока( пСтрока ) Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	строкаБезКомментариев = СокрЛП( КодБезКомментариев( пСтрока ) );
	
	Если ПустаяСтрока( строкаБезКомментариев ) Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Для каждого цЭлемент Из КлючевыеСловаЗавершения() Цикл
		
		Если КодЗаканчиваетсяНа( строкаБезКомментариев, цЭлемент.Ключ, цЭлемент.Значение ) Тогда
			
			Возврат Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если ( КодНачинаетсяНа( строкаБезКомментариев, "Функция", Истина )
		ИЛИ КодНачинаетсяНа( строкаБезКомментариев, "Процедура", Истина ) )
		И КодЗаканчиваетсяНа( строкаБезКомментариев, ")" ) Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Если КодНачинаетсяНа( строкаБезКомментариев, "&На" ) Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Для каждого цЭлемент Из КлючевыеСловаОбласть() Цикл
		
		Если КодНачинаетсяНа( строкаБезКомментариев, цЭлемент.Ключ, цЭлемент.Значение ) Тогда
			
			Возврат Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция СтрокаКодаУвеличенияОтступа( Знач пСтрока )
	
	Если ПустаяСтрока( пСтрока ) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Для каждого цЭлемент Из КлючевыеСловаДляУвеличенияОтступов() Цикл
		
		Если КодНачинаетсяНа( пСтрока, цЭлемент.Ключ, цЭлемент.Значение ) > 0 Тогда
			
			Возврат Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция КодЗаканчиваетсяНа( Знач пСтрокаКода, Знач пФрагмент, Знач ЭтоСлово = Ложь )
	
	Если ПустаяСтрока( пСтрокаКода )
		И Не ПустаяСтрока( пФрагмент ) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	КОД      = ВРег( СокрП( пСтрокаКода ) );
	ФРАГМЕНТ = ВРег( пФрагмент );
	
	позицияФрагмента = ПозицияФрагмента( КОД, ФРАГМЕНТ, ЭтоСлово );
	
	Если позицияФрагмента = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	позицияНачалаФрагментаВКонце = ( СтрДлина( КОД ) -СтрДлина( ФРАГМЕНТ ) + 1 );
	
	Если позицияФрагмента = позицияНачалаФрагментаВКонце Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Если позицияНачалаФрагментаВКонце < позицияФрагмента Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат КодЗаканчиваетсяНа( Сред( КОД, позицияФрагмента + 1 ), пФрагмент, ЭтоСлово );
	
КонецФункции

Функция КодНачинаетсяНа( Знач пСтрокаКода, Знач пФрагмент, Знач ЭтоСлово = Ложь )
	
	КОД      = ВРег( СокрЛ( пСтрокаКода ) );
	ФРАГМЕНТ = ВРег( пФрагмент );
	
	Возврат ПозицияФрагмента( КОД, ФРАГМЕНТ, ЭтоСлово ) = 1;
	
КонецФункции

Функция КодЧислоВхождений( Знач пСтрокаКода, Знач пФрагмент, Знач ЭтоСлово = Ложь )
	
	числоВхождений = 0;
	
	КОД      = ВРег( СокрП( пСтрокаКода ) );
	ФРАГМЕНТ = ВРег( пФрагмент );
	
	позицияФрагмента = ПозицияФрагмента( КОД, ФРАГМЕНТ, ЭтоСлово );
	
	Пока позицияФрагмента > 0 Цикл
		
		числоВхождений = числоВхождений + 1;
		
		КОД = Сред( КОД, позицияФрагмента + 1, ЭтоСлово );
		позицияФрагмента = ПозицияФрагмента( КОД, ФРАГМЕНТ, ЭтоСлово );
		
	КонецЦикла;
	
	Возврат числоВхождений;
	
КонецФункции


// Разбивает строку на несколько строк, используя заданный набор разделителей.
// Если параметр РазделителиСлов не задан, то разделителем слов считается любой из символов,
// не относящихся к символам латиницы, кириллицы, цифры, подчеркивания.
//
// Параметры:
//  Значение        - Строка - исходная строка, которую необходимо разложить на слова.
//  РазделителиСлов - Строка - перечень символов-разделителей. Например, ".,;".
//
// Возвращаемое значение:
//  Массив - список слов.
//
// Пример:
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов("один-@#два2_!три") возвратит массив значений: "один",
//  "два2_", "три"; СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов("один-@#два2_!три", "#@!_") возвратит массив
//  значений: "один-", "два2", "три".
//
Функция РазложитьСтрокуВМассивСлов( Знач Значение ) Экспорт
	
	Слова = Новый Массив;
	
	РазмерТекста = СтрДлина( Значение );
	НачалоСлова  = 1;
	
	Для Позиция = 1 По РазмерТекста Цикл
		
		КодСимвола = КодСимвола( Значение, Позиция );
		
		Если ЭтоРазделительСлов( КодСимвола ) Тогда
			
			Если Позиция <> НачалоСлова Тогда
				
				Слова.Добавить( Сред( Значение, НачалоСлова, Позиция - НачалоСлова ) );
				
			КонецЕсли;
			
			НачалоСлова = Позиция + 1;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Позиция <> НачалоСлова Тогда
		
		Слова.Добавить( Сред( Значение, НачалоСлова, Позиция - НачалоСлова ) );
		
	КонецЕсли;
	
	Возврат Слова;
	
КонецФункции

// Определяет, является ли символ разделителем.
//
// Параметры:
//  КодСимвола      - Число  - код проверяемого символа;
//  РазделителиСлов - Строка - символы разделителей. Если параметр не указан, то
//                             разделителем считаются все символы, не являющиеся цифрами,
//                             латинскими и кириллическими буквами, а также знаком подчеркивания.
//
// Возвращаемое значение:
//  Булево - Истина, если символ с кодом КодСимвола является разделителем.
//
Функция ЭтоРазделительСлов( КодСимвола ) Экспорт
	
	значениеКеша = кэшРазделителиСлов[ КодСимвола ];
	
	Если Не значениеКеша = Неопределено Тогда
		
		Возврат значениеКеша;
		
	КонецЕсли;
	
	Диапазоны = Новый Массив;
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 48, 57 ) );     // цифры
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 65, 90 ) );     // латиница большие
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 97, 122 ) );    // латиница маленькие
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 1040, 1103 ) ); // кириллица
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 1025, 1025 ) ); // символ "Ё"
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 1105, 1105 ) ); // символ "ё"
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 95, 95 ) );     // символ "_"
	
	Для Каждого Диапазон Из Диапазоны Цикл
		
		Если КодСимвола >= Диапазон.Мин И КодСимвола <= Диапазон.Макс Тогда
			
			кэшРазделителиСлов.Вставить( КодСимвола, Ложь );
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	кэшРазделителиСлов.Вставить( КодСимвола, Истина );
	
	Возврат Истина;
	
КонецФункции

Функция ЭтоОтдельноеСлово( Знач пСлово, Знач пСтрока, Знач пПозиция )
	
	слеваРазделитель  = Ложь;
	справаРазделитель = Ложь;
	
	Если пПозиция = 1 Тогда
		
		слеваРазделитель = Истина;
		
	Иначе
		
		слеваРазделитель = ЭтоРазделительСлов( КодСимвола( пСтрока, пПозиция - 1 ) );
		
	КонецЕсли;
	
	позицияПравогоРазделителя = пПозиция + СтрДлина( пСлово );
	
	Если позицияПравогоРазделителя > СтрДлина( пСтрока ) Тогда
		
		справаРазделитель = Истина;
		
	Иначе
		
		справаРазделитель = ЭтоРазделительСлов( КодСимвола( пСтрока, позицияПравогоРазделителя ) );
		
	КонецЕсли;
	
	Возврат слеваРазделитель И справаРазделитель;
	
КонецФункции

Процедура ВыровнитьКодПоФрагменту( ТекстовыйДокумент, Знач пФрагмент )
	
	фрагмент     = пФрагмент.Значение;
	выравнивание = пФрагмент.Представление;
	
	массивСтрок = Новый Массив;
	
	Для цНомерСтроки = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		
		цТекСтрока = ТекстовыйДокумент.ПолучитьСтроку( цНомерСтроки );
		
		Если фрагмент = "(" Тогда
			
			позицияФрагмента = ПозицияОткрывающейсяСкобки( цТекСтрока );
			
		Иначе
			
			позицияФрагмента = ПозицияФрагмента( цТекСтрока, фрагмент );
			
		КонецЕсли;
		
		Если позицияФрагмента > 0
			И ПодходитДляВыравнивания( цТекСтрока, позицияФрагмента ) Тогда
			
			массивСтрок.Добавить( цНомерСтроки );
			
			ТекстовыйДокумент.ЗаменитьСтроку( цНомерСтроки, цТекСтрока );
			
		Иначе
			
			Если массивСтрок.Количество() > 1 Тогда
				
				РазвернутьПробелы( ТекстовыйДокумент, массивСтрок, фрагмент, выравнивание );
				
			Иначе
				
				массивСтрок = Новый Массив;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если массивСтрок.Количество() > 1 Тогда
		
		РазвернутьПробелы( ТекстовыйДокумент, массивСтрок, фрагмент, выравнивание );
		
	КонецЕсли;
	
КонецПроцедуры

Функция ПодходитДляВыравнивания( Знач пСтрока, пИндексФрагмента )
	
	Если Найти( СокрЛ( пСтрока ), "//" ) = 1 Тогда
		
		// Если строка полностью состоит из комментария, то не трогаем ее
		
		Возврат Ложь;
		
	КонецЕсли;
	
	индексКомментария = ПозицияФрагмента( пСтрока, "//" );
	
	Если пИндексФрагмента > индексКомментария
		И Не индексКомментария = 0 Тогда
		
		// Нужный фрагмент закомментирован. Так же стоит учитывать, что выравнивание может происходить как раз комментариев,
		// поэтому сравнение строгое.
		
		Возврат Ложь;
		
	КонецЕсли;
	
	массивСлов = РазложитьСтрокуВМассивСлов( СокрЛП( пСтрока ) );
	
	Если массивСлов.Количество() = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если Не РазделителиБлоков()[ ВРег( массивСлов[0] ) ] = Неопределено Тогда
		
		// Первое слово не является словом, разбивающем блок
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции


Функция УдалитьЛишниеПробельныеСимволы( пСтрока )
	
	Если Не ЗначениеЗаполнено( пСтрока ) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	отступы           = ПолучитьОтступы( пСтрока );
	строкаБезОтступов = СокрЛ( пСтрока );
	
	позицияТаба = ПозицияФрагмента( строкаБезОтступов, "	" );
	
	Пока позицияТаба > 0 Цикл
		
		строкаДо    = Лев( строкаБезОтступов, позицияТаба - 1 );
		строкаПосле = Сред( строкаБезОтступов, позицияТаба + 1 );
		
		строкаБезОтступов = СокрП( строкаДо ) + " " + СокрЛ( строкаПосле );
		
		позицияТаба = ПозицияФрагмента( строкаБезОтступов, "	" );
		
	КонецЦикла;
	
	позицияПробелов = ПозицияФрагмента( строкаБезОтступов, "  " );
	
	Пока позицияПробелов > 0 Цикл
		
		строкаДо    = Лев( строкаБезОтступов, позицияПробелов - 1 );
		строкаПосле = Сред( строкаБезОтступов, позицияПробелов + 1 );
		
		строкаБезОтступов = СокрП( строкаДо ) + " " + СокрЛ( строкаПосле );
		
		позицияПробелов = ПозицияФрагмента( строкаБезОтступов, "  " );
		
	КонецЦикла;
	
	Если Не пСтрока = ( отступы + строкаБезОтступов ) Тогда
		
		пСтрока = отступы + строкаБезОтступов;
		
		Возврат Истина;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции

Функция ПривестиЗапятыеКНорме( пСтрока )
	
	Если Не ЗначениеЗаполнено( пСтрока ) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат  = "";
	остатокСтроки = пСтрока;
	
	позицияЗапятой = ПозицияФрагмента( остатокСтроки, "," );
	
	Если позицияЗапятой = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Пока Не позицияЗапятой = 0 Цикл
		
		строкаПослеЗапятой = Сред( остатокСтроки, позицияЗапятой + 1 );
		строкаДоЗапятой    = Лев( остатокСтроки, позицияЗапятой - 1 );
		
		стрРезультат = стрРезультат + СокрП( строкаДоЗапятой ) + ", ";
		
		остатокСтроки  = СокрЛ( строкаПослеЗапятой );
		позицияЗапятой = ПозицияФрагмента( остатокСтроки, "," );
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + СокрЛ( остатокСтроки );
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция ПривестиЗнакиРавноКНорме( пСтрока )
	
	Если Не ЗначениеЗаполнено( пСтрока ) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат  = "";
	остатокСтроки = пСтрока;
	
	позицияРавно = ПозицияФрагмента( остатокСтроки, "=" );
	
	Если позицияРавно = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Пока Не позицияРавно = 0 Цикл
		
		строкаПослеРавно = Сред( остатокСтроки, позицияРавно + 1 );
		строкаДоРавно    = Лев( остатокСтроки, позицияРавно - 1 );
		
		Если СтрЗаканчиваетсяНа( строкаДоРавно, ">" )
			ИЛИ СтрЗаканчиваетсяНа( строкаДоРавно, "<" ) Тогда
			
			стрРезультат = стрРезультат + СокрП( строкаДоРавно ) + "= ";
			
		Иначе
			
			стрРезультат = стрРезультат + СокрП( строкаДоРавно ) + " = ";
			
		КонецЕсли;
		
		остатокСтроки = СокрЛ( строкаПослеРавно );
		позицияРавно  = ПозицияФрагмента( остатокСтроки, "=" );
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + СокрЛ( остатокСтроки );
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция ПривестиАрифметическиеЗнакиКНорме( пСтрока, Знач пФрагмент, Знач пПредСтрока )
	
	Если Не ЗначениеЗаполнено( пСтрока ) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат   = "";
	длинаФрагмента = СтрДлина( пФрагмент );
	остатокСтроки  = пСтрока;
	
	позицияФрагмента = ПозицияФрагмента( остатокСтроки, пФрагмент );
	
	Если позицияФрагмента = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Пока Не позицияФрагмента = 0 Цикл
		
		строкаПослеФрагмента = Сред( остатокСтроки, позицияФрагмента + длинаФрагмента );
		строкаДоФрагмента    = Лев( остатокСтроки, позицияФрагмента - 1 );
		
		Если ( пФрагмент = "<"
			ИЛИ пФрагмент = ">" )
			И СтрНачинаетсяС( строкаПослеФрагмента, "=" ) Тогда
			
			стрРезультат = стрРезультат + СокрП( строкаДоФрагмента ) + " " + пФрагмент;
			
		ИначеЕсли пФрагмент = "<"
			И СтрНачинаетсяС( строкаПослеФрагмента, ">" ) Тогда
			
			стрРезультат = стрРезультат + СокрП( строкаДоФрагмента ) + " " + пФрагмент;
			
		ИначеЕсли пФрагмент = ">"
			И СтрЗаканчиваетсяНа( строкаДоФрагмента, "<" ) Тогда
			
			стрРезультат = стрРезультат + СокрП( строкаДоФрагмента ) + пФрагмент + " ";
			
		ИначеЕсли ЭтоУнарнаяОперация( строкаДоФрагмента, пПредСтрока, позицияФрагмента, пФрагмент ) Тогда
			
			стрРезультат = стрРезультат + СокрП( строкаДоФрагмента ) + " " + пФрагмент;
			
		Иначе
			
			стрРезультат = стрРезультат + СокрП( строкаДоФрагмента ) + " " + пФрагмент + " ";
			
		КонецЕсли;
		
		остатокСтроки    = СокрЛ( строкаПослеФрагмента );
		позицияФрагмента = ПозицияФрагмента( остатокСтроки, пФрагмент );
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + СокрЛ( остатокСтроки );
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция ПривестиОткрывающиесяСкобкиКНорме( пСтрока )
	
	Если Не ЗначениеЗаполнено( пСтрока ) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат  = "";
	остатокСтроки = пСтрока;
	
	позицияСкобки = ПозицияФрагмента( остатокСтроки, "(" );
	
	Если позицияСкобки = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ДобавлятьПробелыВнутриСкобок() Тогда
		
		пробел = " ";
		
	Иначе
		
		пробел = "";
		
	КонецЕсли;
	
	Пока Не позицияСкобки = 0 Цикл
		
		строкаПослеСкобки = Сред( остатокСтроки, позицияСкобки + 1 );
		строкаДоСкобки    = Лев( остатокСтроки, позицияСкобки - 1 );
		
		стрРезультат = стрРезультат + строкаДоСкобки + "(";
		
		остатокСтроки = СокрЛ( строкаПослеСкобки );
		
		Если Не СтрНачинаетсяС( остатокСтроки, ")" ) Тогда
			
			стрРезультат = стрРезультат + пробел;
			
		КонецЕсли;
		
		позицияСкобки = ПозицияФрагмента( остатокСтроки, "(" );
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + остатокСтроки;
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция ПривестиЗакрывающиесяСкобкиКНорме( пСтрока )
	
	Если Не ЗначениеЗаполнено( пСтрока ) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат  = "";
	остатокСтроки = пСтрока;
	
	позицияСкобки = ПозицияФрагмента( остатокСтроки, ")" );
	
	Если позицияСкобки = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ДобавлятьПробелыВнутриСкобок() Тогда
		
		пробел = " ";
		
	Иначе
		
		пробел = "";
		
	КонецЕсли;
	
	Пока Не позицияСкобки = 0 Цикл
		
		строкаПослеСкобки = Сред( остатокСтроки, позицияСкобки + 1 );
		строкаДоСкобки    = СокрП( Лев( остатокСтроки, позицияСкобки - 1 ) );
		
		Если Не СтрЗаканчиваетсяНа( строкаДоСкобки, "(" ) Тогда
			
			строкаДоСкобки = строкаДоСкобки + пробел;
			
		КонецЕсли;
		
		стрРезультат = стрРезультат + строкаДоСкобки + ")";
		
		остатокСтроки = строкаПослеСкобки;
		
		позицияСкобки = ПозицияФрагмента( остатокСтроки, ")" );
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + остатокСтроки;
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Процедура РазвернутьПробелы( пТекстДок, пМассивСтрок, Знач пФрагмент, Знач пВыравнивание )
	
	Если пМассивСтрок.Количество() = 0 Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ЕстьИзменения = Истина;
	
	максПозиция = 0;
	
	Для каждого цНомерСтроки Из пМассивСтрок Цикл
		
		текСтрока = пТекстДок.ПолучитьСтроку( цНомерСтроки );
		
		максПозиция = Макс( ПозицияФрагмента( текСтрока, пФрагмент ), максПозиция );
		
	КонецЦикла;
	
	размерФрагмента = СтрДлина( пФрагмент );
	
	массивКороткихСтрок = Новый Массив();
	сдвигПревышение     = СдвигПревышение();
	
	Для каждого цНомерСтроки Из пМассивСтрок Цикл
		
		текСтрока = пТекстДок.ПолучитьСтроку( цНомерСтроки );
		
		индексФрагмента = ПозицияФрагмента( текСтрока, пФрагмент );
		
		Если максПозиция - индексФрагмента > сдвигПревышение Тогда
			
			массивКороткихСтрок.Добавить( цНомерСтроки );
			Продолжить;
			
		КонецЕсли;
		
		СтрокаПробелов = СтрокаПробелов( максПозиция - индексФрагмента );
		
		Если пВыравнивание = "Право" Тогда
			
			НоваяСтрока = Лев( текСтрока, индексФрагмента - 1 ) + СтрокаПробелов + Сред( текСтрока, индексФрагмента );
			
		ИначеЕсли пВыравнивание = "Лево" Тогда
			
			строкаДоПробелов = Лев( текСтрока, индексФрагмента + размерФрагмента - 1 );
			строкаПосле      = Сред( текСтрока, индексФрагмента + размерФрагмента );
			
			НоваяСтрока = строкаДоПробелов + СтрокаПробелов + строкаПосле;
			
		КонецЕсли;
		
		пТекстДок.ЗаменитьСтроку( цНомерСтроки, СокрП( НоваяСтрока ) );
		
	КонецЦикла;
	
	РазвернутьПробелы( пТекстДок, массивКороткихСтрок, пФрагмент, пВыравнивание );
	
	пМассивСтрок = Новый Массив;
	
КонецПроцедуры

Функция СтрокаПробелов( Знач пКоличествоПробелов )
	
	СтрокаПробелов = "";
	
	Для СчПробелов = 1 По пКоличествоПробелов Цикл
		
		СтрокаПробелов = СтрокаПробелов + " ";
		
	КонецЦикла;
	
	Возврат СтрокаПробелов;
	
КонецФункции

Функция УдалитьПробелыСправа( пСтрока )
	
	Если Не ЗначениеЗаполнено( пСтрока ) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если пСтрока = СокрП( пСтрока ) Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = СокрП( пСтрока );
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция ЭтоУнарнаяОперация( Знач пСтрокаДоФрагмента, Знач пПредСтрока, Знач пПозицияФрагмента, Знач пФрагмент )
	
	Если Не пФрагмент = "-" Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ПустаяСтрока( пСтрокаДоФрагмента ) Тогда
		
		пСтрокаДоФрагмента = пПредСтрока;
		
	КонецЕсли;
	
	Для каждого цСлово Из КлючевыеСловаДляИсключенияПеременных() Цикл
		
		Если КодЗаканчиваетсяНа( пСтрокаДоФрагмента, цСлово.Ключ, цСлово.Значение ) Тогда
			
			Возврат Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции


Функция СдвинутьКодПоИнструкциямПрепроцессора( пТекСтрока, пТекущийСдвиг )
	
	строкаИзменена = Ложь;
	
	Для ц = 1 По пТекущийСдвиг Цикл
		
		Если СтрНачинаетсяС( пТекСтрока, "	" ) Тогда
			
			пТекСтрока     = Сред( пТекСтрока, 2 );
			строкаИзменена = Истина;
			
		ИначеЕсли СтрНачинаетсяС( пТекСтрока, "    " ) Тогда
			
			пТекСтрока     = Сред( пТекСтрока, 5 );
			строкаИзменена = Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для каждого цСловоНачало Из КлючевыеСловаПрепроцессораНачало() Цикл
		
		Если КодНачинаетсяНа( пТекСтрока, цСловоНачало.Ключ, цСловоНачало.Значение ) Тогда
			
			пТекущийСдвиг = пТекущийСдвиг + 1;
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для каждого цСловоНачало Из КлючевыеСловаПрепроцессораКонец() Цикл
		
		Если КодНачинаетсяНа( пТекСтрока, цСловоНачало.Ключ, цСловоНачало.Значение ) Тогда
			
			пТекущийСдвиг = пТекущийСдвиг - 1;
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат строкаИзменена;
	
КонецФункции


Функция УстановитьОтступПеренесеннымСтрокам( пТекСтрока, Знач предСтрока, этоСерияПеренесенныхВыражений )
	
	Если ЭтоЗавершеннаяСтрокаКода( предСтрока ) Тогда
		
		этоСерияПеренесенныхВыражений = Ложь;
		
		Возврат Ложь;
		
	КонецЕсли;
	
	новыйОтступ = СформироватьОтступПеренесеннойСтроке( пТекСтрока, предСтрока, Не этоСерияПеренесенныхВыражений );
	
	этоСерияПеренесенныхВыражений = Истина;
	
	новТекСтрока = новыйОтступ + СокрЛ( пТекСтрока );
	
	Если пТекСтрока = новТекСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пТекСтрока = новТекСтрока;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции


// 0 - не добавлять
// 1 - добавить пустую строку после, если у следующей строки не 1
// 2 - добавить пустую строку после
// 3 - добавить пустую строку до
// 4 - добавить пустые строки до и после.
Функция ОкружитьПустымиСтроками( Знач пСтрока )
	
	СТРОКА = ВРег( пСтрока );
	
	текУровень = 0;
	
	Для каждого цЭлемент Из КлючевыеСловаДляДобавленияПустыхСтрок() Цикл
		
		Если ПозицияФрагмента( СТРОКА, цЭлемент.Ключ, Истина ) > 0 Тогда
			
			Если цЭлемент.Значение = 4 Тогда
				
				текУровень = 4;
				Прервать;
				
			ИначеЕсли цЭлемент.Значение = 3
				И текУровень = 2 Тогда
				
				текУровень = 4;
				Прервать;
				
			ИначеЕсли цЭлемент.Значение = 2
				И текУровень = 3 Тогда
				
				текУровень = 4;
				Прервать;
				
			Иначе
				
				текУровень = Макс( текУровень, цЭлемент.Значение );
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат текУровень;
	
КонецФункции


Функция ДобавитьПустуюСтрокуДо( Знач пТекСтрока, Знач пПредСтрока )
	
	Если Не ДобавлятьПустыеСтрокиВокругКлючевыхКонструкций() Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ПустаяСтрока( пПредСтрока )
		ИЛИ СтрНачинаетсяС( СокрЛ( пПредСтрока ), "//" ) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если СтрНачинаетсяС( СокрЛ( пТекСтрока ), "//" )
		И ДобавлятьПустыеСтрокиПередКомментарием() Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	// Перед директивами компиляции всегда добавляем пустую строку
	Если СтрНачинаетсяС( пТекСтрока, "&На" ) Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	режимДобавления = ОкружитьПустымиСтроками( пТекСтрока );
	
	Возврат режимДобавления = 4 ИЛИ режимДобавления = 3;
	
КонецФункции

Функция ДобавитьПустуюСтрокуПосле( Знач пТекСтрока, Знач пПредСтрока, пОтложеннаяУстановка )
	
	Если Не ДобавлятьПустыеСтрокиВокругКлючевыхКонструкций() Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ПустаяСтрока( пТекСтрока ) Тогда
		
		пОтложеннаяУстановка = Ложь;
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если пОтложеннаяУстановка
		И ЭтоЗавершеннаяСтрокаКода( пПредСтрока ) Тогда
		
		пОтложеннаяУстановка = Ложь;
		
		Возврат Истина;
		
	КонецЕсли;
	
	режимДобавления = ОкружитьПустымиСтроками( пПредСтрока );
	
	добавитьПустуюСтроку = Ложь;
	
	Если режимДобавления = 2
		ИЛИ режимДобавления = 4 Тогда
		
		добавитьПустуюСтроку = Истина;
		
	КонецЕсли;
	
	Если режимДобавления = 1
		И Не ОкружитьПустымиСтроками( пТекСтрока ) = 1 Тогда
		
		добавитьПустуюСтроку = Истина;
		
	КонецЕсли;
	
	Если добавитьПустуюСтроку Тогда
		
		Если Не ЭтоЗавершеннаяСтрокаКода( пПредСтрока ) Тогда
			
			пОтложеннаяУстановка = Истина;
			
			Возврат Ложь;
			
		Иначе
			
			пОтложеннаяУстановка = Ложь;
			
			Возврат Истина;
			
		КонецЕсли;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции

// Режим = 0 - обычный вызов
// режим = 1 - разбивка по запятым
// режим = 2 - разбивка по И/ИЛИ.
Процедура РазбитьДлинныеВыражения( пТекСтрока, строкаИзменена, режим = 0, этоСерияПеренесенныхВыражений )
	
	Если режим = 0 Тогда
		
		позицияКомментария = ПозицияФрагмента( пТекСтрока, "//" );
		
		Если Не позицияКомментария = 0
			И позицияКомментария < ОграничениеДлиныСтроки() Тогда
			
			Возврат;
			
		КонецЕсли;
		
		Если СтрДлина( пТекСтрока ) < ОграничениеДлиныСтроки() Тогда
			
			Возврат;
			
		КонецЕсли;
		
	КонецЕсли;
	
	отступы       = ПолучитьОтступы( пТекСтрока );
	длинаОтступов = СтрЧислоВхождений( отступы, " " ) + 4*СтрЧислоВхождений( отступы, "	" );
	
	списокРазрывов = Новый СписокЗначений;
	
	Если режим = 0 Тогда
		
		позицияЗапятой = ПозицияФрагмента( пТекСтрока, ",", Ложь );
		позицияСкобки  = ПозицияОткрывающейсяСкобки( пТекСтрока );
		
		Если позицияЗапятой < ОграничениеДлиныСтроки()
			ИЛИ позицияСкобки = 0
			ИЛИ позицияСкобки > позицияЗапятой Тогда
			
			списокРазрывов.Добавить( позицияЗапятой, "," );
			
		Иначе
			
			списокРазрывов.Добавить( позицияСкобки, "(" );
			
		КонецЕсли;
		
	ИначеЕсли режим = 1 Тогда
		
		списокРазрывов.Добавить( ПозицияФрагмента( пТекСтрока, ",", Ложь ), "," );
		списокРазрывов.Добавить( ПозицияОткрывающейсяСкобки( пТекСтрока ), "(" );
		
	КонецЕсли;
	
	Если режим = 0
		ИЛИ режим = 2 Тогда
		
		списокРазрывов.Добавить( ПозицияРазрыва( пТекСтрока, "И", Истина ), "И" );
		списокРазрывов.Добавить( ПозицияРазрыва( пТекСтрока, "ИЛИ", Истина ), "ИЛИ" );
		
	КонецЕсли;
	
	списокРазрывов.СортироватьПоЗначению( НаправлениеСортировки.Возр );
	
	Для каждого цРазрыв Из списокРазрывов Цикл
		
		Если цРазрыв.Значение = 0 Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		Если цРазрыв.Представление = "," Тогда
			
			позицияРазрыва = цРазрыв.Значение - 1 + СтрДлина( цРазрыв.Представление );
			
			строкаДоРазрыва    = СокрП( Лев( пТекСтрока, позицияРазрыва ) );
			строкаПослеРазрыва = СокрЛ( Сред( пТекСтрока, позицияРазрыва + 1 ) );
			
			новРежим = 1;
			
		ИначеЕсли цРазрыв.Представление = "(" Тогда
			
			позицияРазрыва = цРазрыв.Значение - 1 + СтрДлина( цРазрыв.Представление );
			
			строкаДоРазрыва    = СокрП( Лев( пТекСтрока, позицияРазрыва ) );
			строкаПослеРазрыва = СокрЛ( Сред( пТекСтрока, позицияРазрыва + 1 ) );
			
			новРежим = 1;
			
		Иначе
			
			позицияРазрыва = цРазрыв.Значение - 1;
			
			строкаДоРазрыва    = СокрП( Лев( пТекСтрока, позицияРазрыва - 1 ) );
			строкаПослеРазрыва = СокрЛ( Сред( пТекСтрока, позицияРазрыва ) );
			
			новРежим = 2;
			
		КонецЕсли;
		
		Если ПустаяСтрока( строкаПослеРазрыва ) Тогда
			
			этоСерияПеренесенныхВыражений = Истина;
			
			Возврат;
			
		КонецЕсли;
		
		новыйОтступ = СформироватьОтступПеренесеннойСтроке( строкаПослеРазрыва, строкаДоРазрыва, режим = 0 );
		
		пТекСтрока = новыйОтступ + строкаПослеРазрыва;
		
		строкаИзменена = Истина;
		ДобавитьВРезультат( строкаДоРазрыва );
		
		РазбитьДлинныеВыражения( пТекСтрока, строкаИзменена, новРежим, этоСерияПеренесенныхВыражений );
		
		Возврат;
		
	КонецЦикла;
	
КонецПроцедуры

Функция СформироватьОтступПеренесеннойСтроке( Знач пТекСтрока,
											  Знач пПредСтрока,
											  Знач пЭтоПерваяСтрокаВВыравнивании = Ложь )
                                              
	исхОтступы    = ПолучитьОтступы( пПредСтрока );
	отступы       = ТабыВПробелы( исхОтступы );
	пПредСтрока   = отступы + СокрЛ( пПредСтрока );
	длинаОтступов = СтрДлина( отступы );
	
	новыйОтступ = "";
	
	Если КодЗаканчиваетсяНа( пПредСтрока, "," ) Тогда
		
		// Найдем открывающуюся скобку, по которой можно выровнять следующую строку
		
		позицияСкобки = ПозицияОткрывающейсяСкобки( пПредСтрока );
		
		Если КодЧислоВхождений( пПредСтрока, "(" ) <= КодЧислоВхождений( пПредСтрока, ")" ) Тогда
			
			позицияСкобки = 0;
			
		КонецЕсли;
		
		количествоПробелов = 0;
		
		Если позицияСкобки > 0 Тогда
			
			строкаПослеСкобки = Сред( пПредСтрока, позицияСкобки + 1 );
			
			сдвигЗнач = ПолучитьСдвигЗнач( пТекСтрока, строкаПослеСкобки );
			
			Если ДобавлятьПробелыВнутриСкобок() Тогда
				
				позицияСкобки = позицияСкобки + 1;
				
			КонецЕсли;
			
			количествоПробелов = позицияСкобки - длинаОтступов + сдвигЗнач;
			
		ИначеЕсли пЭтоПерваяСтрокаВВыравнивании Тогда
			
			количествоПробелов = 4;
			
		Иначе
			
			сдвигЗнач          = ПолучитьСдвигЗнач( пТекСтрока, пПредСтрока );
			количествоПробелов = сдвигЗнач;
			
		КонецЕсли;
		
		Если ПозицияЗакрывающейсяСкобки( пПредСтрока ) > 0
			И КодЧислоВхождений( пПредСтрока, "(" ) < КодЧислоВхождений( пПредСтрока, ")" ) Тогда
			
			количествоПробелов = количествоПробелов - 4;
			
		КонецЕсли;
		
		строкаПробелов = СтрокаПробелов( длинаОтступов + количествоПробелов );
		новыйОтступ    = ПробелыВТабы( строкаПробелов );
		
	ИначеЕсли КодНачинаетсяНа( пТекСтрока, "И", Истина )
		ИЛИ КодНачинаетсяНа( пТекСтрока, "ИЛИ", Истина ) Тогда
		
		Если пЭтоПерваяСтрокаВВыравнивании Тогда
			
			строкаПробелов = "	";
			
		Иначе
			
			строкаПробелов = "";
			
		КонецЕсли;
		
		новыйОтступ = ПробелыВТабы( отступы + строкаПробелов );
		
	ИначеЕсли ( КодНачинаетсяНа( пПредСтрока, "|" )
		ИЛИ КодНачинаетсяНа( пПредСтрока, """" ) )
		И КодНачинаетсяНа( пТекСтрока, "|" ) Тогда
		
		новыйОтступ = ПробелыВТабы( отступы + "" );
		
	ИначеЕсли ( КодНачинаетсяНа( пТекСтрока, "|" )
		ИЛИ КодНачинаетсяНа( пТекСтрока, """" ) )
		И Не КодНачинаетсяНа( пПредСтрока, """" ) Тогда
		
		режимПереносаСтрок = РежимВыравниванияТекстов();
		
		Если режимПереносаСтрок = 0 Тогда
			
			новыйОтступ = ПробелыВТабы( отступы + "" );
			
		ИначеЕсли режимПереносаСтрок = 1 Тогда
			
			новыйОтступ = ПробелыВТабы( отступы + "	" );
			
		ИначеЕсли режимПереносаСтрок = 2 Тогда
			
			позицияСкобки = ПозицияОткрывающейсяСкобки( пПредСтрока );
			позицияРавно  = ПозицияФрагмента( пПредСтрока, "=" );
			
			Если позицияРавно = 0
				И позицияСкобки = 0 Тогда
				
				позицияВыравнивания = 0;
				
			ИначеЕсли ( позицияРавно > 0
				И позицияСкобки > позицияРавно )
				ИЛИ позицияСкобки = 0 Тогда
				
				позицияВыравнивания = позицияРавно;
				
			Иначе
				
				позицияВыравнивания = позицияСкобки;
				
			КонецЕсли;
			
			Если позицияВыравнивания < ОграничениеСдвига()
				И позицияВыравнивания > 0 Тогда
				
				количествоПробелов = позицияВыравнивания - длинаОтступов;
				строкаПробелов     = СтрокаПробелов( длинаОтступов + количествоПробелов + 1 );
				новыйОтступ        = ПробелыВТабы( строкаПробелов );
				
			Иначе
				
				новыйОтступ = ПробелыВТабы( отступы + "	" );
				
			КонецЕсли;
			
		КонецЕсли;
		
	ИначеЕсли КодЗаканчиваетсяНа( пПредСтрока, "=" ) Тогда
		
		Если СтрДлина( ТабыВПробелы( пПредСтрока ) ) < ОграничениеСдвига() Тогда
			
			строкаПробелов = СтрокаПробелов( СтрДлина( пПредСтрока ) -длинаОтступов + 1 );
			
			новыйОтступ = ПробелыВТабы( отступы + строкаПробелов );
			
		Иначе
			
			новыйОтступ = ПробелыВТабы( отступы + "	" );
			
		КонецЕсли;
		
	ИначеЕсли КодЗаканчиваетсяНа( пПредСтрока, "(" ) Тогда
		
		новыйОтступ = ПробелыВТабы( отступы + "	" );
		
	ИначеЕсли пЭтоПерваяСтрокаВВыравнивании Тогда
		
		новыйОтступ = ПробелыВТабы( отступы + "	" );
		
	Иначе
		
		новыйОтступ = отступы;
		
	КонецЕсли;
	
	Если ИспользоватьПробелыДляВыравнивания() Тогда
		
		// вернем исходные табы в начало
		
		исхОтступы         = СтрЗаменить( исхОтступы, " ", "" );
		количествоТабов    = СтрЧислоВхождений( исхОтступы, "	" );
		количествоПробелов = количествоТабов * 4;
		новыйОтступ        = ТабыВПробелы( новыйОтступ );
		
		Если СтрДлина( новыйОтступ ) > количествоПробелов
			И количествоПробелов > 0 Тогда
			
			новыйОтступ = исхОтступы + Сред( новыйОтступ, количествоПробелов + 1 );
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат новыйОтступ;
	
КонецФункции

Функция ПолучитьСдвигЗнач( Знач пТекСтрока, Знач строкаПослеСкобки )
	
	сдвигЗнач = 0;
	
	Если СтрНачинаетсяС( СокрЛ( ВРег( строкаПослеСкобки ) ), ВРег( "Знач " ) ) Тогда
		
		сдвигЗнач = сдвигЗнач + 5;
		
	КонецЕсли;
	
	Если СтрНачинаетсяС( СокрЛ( ВРег( пТекСтрока ) ), ВРег( "Знач " ) ) Тогда
		
		сдвигЗнач = сдвигЗнач - 5;
		
	КонецЕсли;
	
	Возврат сдвигЗнач;
	
КонецФункции

ЕстьИзменения      = Ложь;
кэшРазделителиСлов = Новый Соответствие;

Настройки = Новый Соответствие;

